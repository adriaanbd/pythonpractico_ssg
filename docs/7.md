# 7. Temas Avanzados

En esta sección, veremos una pequeña colección de algunas características avanzadas de Python que posiblemente encontremos en nuestra programación cotidiana. Los temas en esta sección son sólo una introducción a estas ideas.

## 7.1 Argumentos variables

Esta sección cubre los argumentos de funciones variadas, a veces descritos como *argsy **kwargs.

### 7.1.1 Argumentos de variables posicionales (`*args`)

Se dice que una función que acepta cualquier número de argumentos usa argumentos variables. Por ejemplo:

```python
def f(x, *args):
    ...
```

Llamada de función.

```python
f(1,2,3,4,5)
```

Los argumentos adicionales se pasan como una tupla.

```python
def f(x, *args):
    # x -> 1
    # args -> (2,3,4,5)
```

### 7.1.2 Argumentos de variables de palabra clave (`**kwargs`)

Una función también puede aceptar cualquier número de argumentos de palabras clave. Por ejemplo:

```python
def f(x, y, **kwargs):
    ...
```

Llamada de función.

```python
f(2, 3, flag=True, mode='fast', header='debug')
```

Las palabras clave adicionales se pasan en un diccionario.

```python
def f(x, y, **kwargs):
    # x -> 2
    # y -> 3
    # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' }
```

### 7.1.3 Combinando ambos

Una función también puede aceptar cualquier número de argumentos variables de palabras clave y no palabras clave.

```python
def f(*args, **kwargs):
    ...
```

Llamada de función.

```python
f(2, 3, flag=True, mode='fast', header='debug')
```

Los argumentos se separan en componentes posicionales y de palabras clave

```python
def f(*args, **kwargs):
    # args = (2, 3)     # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' }     ...
```

Esta función toma cualquier combinación de argumentos posicionales o de palabras clave. A veces se usa al escribir envoltorios o cuando desea pasar argumentos a otra función.

### 7.1.4 Pasar tuplas y dictados

Las tuplas se pueden expandir en argumentos variables.

```python
numbers = (2,3,4)
f(1, *numbers)      # Same as f(1,2,3,4)
```

Los diccionarios también se pueden expandir a argumentos de palabras clave.

```python
options = {
    'color' : 'red',
    'delimiter' : ',',
    'width' : 400
}
f(data, **options)
# Same as f(data, color='red', delimiter=',', width=400)
```
### 7.1.5 Ejercicios

#### Ejercicio 7.1: un ejemplo simple de argumentos variables

Intente definir la siguiente función:

```python
>>> def avg(x,*more):
        return float(x+sum(more))/(1+len(more))

>>> avg(10,11)
10.5
>>> avg(3,4,5)
4.0
>>> avg(1,2,3,4,5,6)
3.5
>>>
```

Observe cómo el parámetro *morerecopila todos los argumentos adicionales.

#### Ejercicio 7.2: Pasar tuplas y dictados como argumentos

Suponga que lee algunos datos de un archivo y obtiene una tupla como esta:

```python
>>> data = ('GOOG', 100, 490.1)
>>>
```

Ahora, suponga que desea crear un objeto `Stock` a partir de estos datos. Si intenta pasar `data` directamente, no funciona:

```python
>>> from stock import Stock
>>> s = Stock(data)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __init__() takes exactly 4 arguments (2 given)
>>>
```

Esto se soluciona fácilmente usando `*data` en su lugar. Prueba esto:

```python
>>> s = Stock(*data)
>>> s
Stock('GOOG', 100, 490.1)
>>>
```

Si tiene un diccionario, puede utilizar `**` en su lugar. Por ejemplo:

```python
>>> data = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 }
>>> s = Stock(**data)
Stock('GOOG', 100, 490.1)
>>>
```

#### Ejercicio 7.3: Crear una lista de instancias

En su programa `report.py`, creó una lista de instancias usando un código como este:

```python
def read_portfolio(filename):
    ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. '''
    with open(filename) as lines:
        portdicts = fileparse.parse_csv(lines,
                               select=['name','shares','price'],
                               types=[str,int,float])

    portfolio = [ Stock(d['name'], d['shares'], d['price'])
                  for d in portdicts ]
    return Portfolio(portfolio)
```

Puede simplificar ese código usando `Stock(**d)`. Haz ese cambio.

#### Ejercicio 7.4: Transferencia de argumentos

La función `fileparse.parse_csv()` tiene algunas opciones para cambiar el delimitador de archivos y para informar de errores. Tal vez le gustaría exponer esas opciones a la función `read_portfolio()` anterior. Haz este cambio:

```python
def read_portfolio(filename, **opts):
    '''
    Read a stock portfolio file into a list of dictionaries with keys
    name, shares, and price.
    '''
    with open(filename) as lines:
        portdicts = fileparse.parse_csv(lines,
                                        select=['name','shares','price'],
                                        types=[str,int,float],
                                        **opts)

    portfolio = [ Stock(**d) for d in portdicts ]
    return Portfolio(portfolio)
```

Una vez que haya realizado el cambio, intente leer un archivo con algunos errores:

```python
>>> import report
>>> port = report.read_portfolio('Data/missing.csv')
Row 4: Couldn't convert ['MSFT', '', '51.23'] Row 4: Reason invalid literal for int() with base 10: '' Row 7: Couldn't convert ['IBM', '', '70.44']
Row 7: Reason invalid literal for int() with base 10: ''
>>>
```

Ahora, intente silenciar los errores:

```python
>>> import report
>>> port = report.read_portfolio('Data/missing.csv', silence_errors=True)
>>>
```

## 7.2 Funciones anónimas y lambda

## 7.3 Función de devolución y cierres
## 7.4 Decoradores de funciones
## 7.5 Métodos estáticos y de clase
