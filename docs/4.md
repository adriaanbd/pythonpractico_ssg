# 4. Clases y Objetos

Introduciremos el concepto de clases y objetos. Aprenderemos sobre la 
declaración class que nos permite crear nuevos objetos. También 
introcimos el concepto de inherencia, unaherramienta que es 
comunmente utilizada para construir programar extensibles. 
Finalmente, veremos otras características de clases como los métodos 
especiales, búsqueda dinamica de atributos, y la definición de nuevas 
excepciones.

## 4.1 Clases

Esta sección presenta la declaración de clase y la idea de crear 
nuevos objetos.

### 4.1.1 Programación orientada a objetos (OO)

Una técnica de programación en la que el código se organiza como una 
colección de objetos .

Un objeto consta de:

* Datos. Atributos
* Comportamiento. Métodos que son funciones aplicadas al objeto.

Ya ha estado utilizando OO durante este curso.

Por ejemplo, manipular una lista.

```python
>>> nums = [1, 2, 3]
>>> nums.append(4)      # Metodo
>>> nums.insert(1,10)   # Metodo 
>>> nums
[1, 10, 2, 3, 4]        # Data 
>>>
```
`nums` es una instancia de una lista.

Los métodos (`append()` e `insert()`) se adjuntan a la instancia 
(`nums`).

La declaración `class`

Utilice la declaración `class` para definir un nuevo objeto.

```python
class Player:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.health = 100

    def move(self, dx, dy):
        self.x += dx
        self.y += dy

    def damage(self, pts):
        self.health -= pts
```

En pocas palabras, una clase es un conjunto de funciones que realizan 
varias operaciones en las denominadas *instancias*.

### 4.1.2 Instancias

Las instancias son los objetos reales que manipula en su programa.

Se crean llamando a la clase como función.

```python
>>> a = Player(2, 3)
>>> b = Player(10, 20)
>>>
```

`a` y `b` son instancias de `Player`.

*Importante: La declaración de clase es solo la definición 
(no hace nada por sí misma). Similar a la definición de una función.*

### 4.1.3 Datos de instancia

Cada instancia tiene sus propios datos locales.

```python
>>> a.x
2
>>> b.x
10
```

Estos datos son inicializados por `__init__()`.

```python
class Player:
    def __init__(self, x, y):
        # Cualquier valor guardado en `self` es data de la instancia         
        self.x = x
        self.y = y
        self.health = 100
```

No hay restricciones sobre el número total o el tipo de atributos 
almacenados.

### 4.1.4 Métodos de instancia

Los métodos de instancia son funciones aplicadas a instancias de un 
objeto.

```python
class Player:
    ...
    # `move` es un metodo     
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
```

El objeto en sí siempre se pasa como primer argumento.

```python
>>> a.move(1, 2)

# empareja `a` a `self` 
# empareja `1` a `dx` 
# empareja `2` a `dy` 
def move(self, dx, dy):
```
Por convención, se llama la instancia `self`. Sin embargo, el nombre 
real utilizado no es importante. El objeto siempre se pasa como 
primer argumento. Es simplemente estilo de programación Python para 
llamar a este argumento `self`.

### 4.1.5 Alcance de la clase

Las clases no definen un ámbito / espacio de nombres.

```python
class Player:
    ...
    def move(self, dx, dy):
        self.x += dx
        self.y += dy

    def left(self, amt):
        move(-amt, 0)       # NO. Llama función global `move`         
        self.move(-amt, 0)  # SI. Llama metodo `move` de arriba. 
```

Si desea operar en una instancia, siempre se refiere a ella 
explícitamente (por ejemplo, `self`).

### 4.1.6 Ejercicios

A partir de este conjunto de ejercicios, comenzamos a realizar una 
serie de cambios en el código existente de las secciones anteriores. 
Es fundamental que tenga una versión funcional del ejercicio 3.18 
para comenzar. Si no la tiene, trabaje con el código de solución que 
se encuentra en el directorio `Solutions/3_18`. Está bien copiarlo.

#### 4.1.7 Ejercicio 4.1: Objetos como estructuras de datos

En la sección 2 y 3, trabajamos con datos representados como tuplas y 
diccionarios. Por ejemplo, una tenencia de acciones podría 
representarse como una tupla como esta:

```python
s = ('GOOG',100,490.10)
```
o como un diccionario como este:

```python
s = { 'name'   : 'GOOG',
      'shares' : 100,
      'price'  : 490.10
}
```

Incluso puede escribir funciones para manipular dichos datos. 

Por ejemplo:

```python
def cost(s):
    return s['shares'] * s['price']
```

Sin embargo, a medida que su programa crece, es posible que desee 
crear un mejor sentido de organización. Por lo tanto, otro enfoque 
para representar datos sería definir una clase. Cree un archivo 
llamado `stock.py` y defina una clase `Stock` que represente una sola 
tenencia de acciones. Las instancias de `Stock` deben tener los 
atributos de `name`, `shares` y `price`. Por ejemplo:

```python
>>> import stock
>>> a = stock.Stock('GOOG',100,490.10)
>>> a.name
'GOOG'
>>> a.shares
100
>>> a.price
490.1
>>>
```

Cree algunos objetos `Stock` más y manipúlelos. Por ejemplo:

```python
>>> b = stock.Stock('AAPL', 50, 122.34)
>>> c = stock.Stock('IBM', 75, 91.75)
>>> b.shares * b.price
6117.0
>>> c.shares * c.price
6881.25
>>> stocks = [a, b, c]
>>> stocks
[<stock.Stock object at 0x37d0b0>, <stock.Stock object at 0x37d110>, 
<stock.Stock object at 0x37d050>]
>>> for s in stocks:
     print(f'{s.name:>10s} {s.shares:>10d} {s.price:>10.2f}')

... mire la salida ...
>>>
```

Una cosa a enfatizar aquí es que la clase `Stock` actúa como una 
fábrica para crear instancias de objetos. Básicamente, la llamas como 
una función y crea un nuevo objeto para ti. Además, debe enfatizarse 
que cada objeto es distinto: cada uno tiene sus propios datos que 
están separados de otros objetos que se han creado.

Un objeto definido por una clase es algo similar a un diccionario, 
solo que con una sintaxis algo diferente. Por ejemplo, en lugar de 
escribir `s['name']` o `s['price']`, ahora escribe `s.name` y 
`s.price`.

#### Ejercicio 4.2: Adición de algunos métodos

Con las clases, puede adjuntar funciones a sus objetos. Estos se 
conocen como métodos y son funciones que operan sobre los datos 
almacenados dentro de un objeto. Agregue un método `cost()` y 
`sell()` a su objeto `Stock`. Deberían funcionar así:

```python
>>> import stock
>>> s = stock.Stock('GOOG', 100, 490.10)
>>> s.cost()
49010.0
>>> s.shares
100
>>> s.sell(25)
>>> s.shares
75
>>> s.cost()
36757.5
>>>
```

#### Ejercicio 4.3: Creando una lista de instancias

Pruebe estos pasos para hacer una lista de instancias de `Stock` a 
partir de una lista de diccionarios. Luego calcule el costo total:

```python
>>> import fileparse
>>> with open('Data/portfolio.csv') as lines:
...     portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float])
...
>>> portfolio = [ stock.Stock(d['name'], d['shares'], d['price']) for d in portdicts]
>>> portfolio
[<stock.Stock object at 0x10c9e2128>, <stock.Stock object at 0x10c9e2048>, <stock.Stock object at 0x10c9e2080>,
 <stock.Stock object at 0x10c9e25f8>, <stock.Stock object at 0x10c9e2630>, <stock.Stock object at 0x10ca6f748>,
 <stock.Stock object at 0x10ca6f7b8>]
>>> sum([s.cost() for s in portfolio])
44671.15
>>>
```

#### Ejercicio 4.4: Usar tu clase

Modifique la función `read_portfolio()` en el programa `report.py` 
para que lea un portafolio en una lista de instancias `Stock` como se 
muestra en el ejercicio 4.3. Una vez que haya hecho eso, modifique 
todo el código en `report.py` y `pcost.py` para que funcione con 
`Stock` casos en lugar de los diccionarios.

Sugerencia: no debería tener que realizar cambios importantes en el 
código. Principalmente, cambiará el acceso al diccionario, como 
`s['shares']` en `s.shares`.

Debería poder ejecutar sus funciones de la misma manera que antes:

```python
>>> import pcost
>>> pcost.portfolio_cost('Data/portfolio.csv')
44671.15
>>> import report
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
>>>
```

