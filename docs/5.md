# 5. Funcionamiento interno del objeto Python

En esta sección aprenderemos sobre el funcionamiento interno de los objetos en Python. Algunos programadores con experiencia en otros lenguajes de programación a menudo encuentran que la noción de clases en Python carece de ciertas características. Por ejemplo, no existe la noción de control de accesso (e.g. privado, protegido), el argumento self lo encuentran extraño, y trabajar con objetos se siente como una actividad con mucho libertinaje. Conoceremos como todo funciona y algunos patrones comunes para la encapsulación interna de objetos.

## 5.1 Diccionarios revisados

### 5.1.1 Diccionarios revisados
### 5.1.2 Dictados y módulos
### 5.1.3 Dictados y objetos
### 5.1.4 Miembros de la clase
### 5.1.5 Instancias y clases
### 5.1.6 Acceso a atributos
### 5.1.7 Modificar instancias
### 5.1.8 Atributos de lectura
### 5.1.9 Cómo funciona la herencia
### 5.1.10 Lectura de atributos con herencia
### 5.1.11 Lectura de atributos con herencia única
### 5.1.12 Orden de resolución de método o MRO
### 5.1.13 MRO en herencia múltiple
### 5.1.14 Una reutilización de código extraño (que implica herencia múltiple)
### 5.1.15 El patrón "Mixin"
### 5.1.16 Por qué super()
### 5.1.17 Algunas precauciones
### 5.1.18 Ejercicios
#### Ejercicio 5.1: Representación de instancias
#### Ejercicio 5.2: Modificación de datos de instancia
#### Ejercicio 5.3: El papel de las clases
#### Ejercicio 5.4: métodos ligados
#### Ejercicio 5.5: Herencia

## 5.2 Clases y encapsulación
### 5.2.1 Público vs Privado
### 5.2.2 Un problema
### 5.2.3 Encapsulación de Python
### 5.2.4 Atributos privados
### 5.2.5 Atributos simples
### 5.2.6 Atributos gestionados
### 5.2.7 Propiedades
### 5.2.8 Acceso uniforme
### 5.2.9 Sintaxis del decorador
### 5.2.10 __slots__ Atributo
### 5.2.11 Comentarios finales sobre encapsulación
### 5.2.12 Ejercicios
#### Ejercicio 5.6: Propiedades simples
#### Ejercicio 5.7: Propiedades y establecedores
#### Ejercicio 5.8: Agregar ranuras
