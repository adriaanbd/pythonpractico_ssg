# 6. Generadores

La iteración es uno de los más comunes patrones de programación en Python. Los programas hacen mucha iteración para procesar listas, leer archivos, consultar una base de datos, y más. Una de las características mas poderosas de Python es la habilidad de costumizar y redefinir la iteración en una función generadora. Al final de la sección, escribiremos algunos programas que procesan datos en tiempo real en una manera interesante.
## 6.1 Protocolo de iteración

Esta sección analiza el proceso subyacente de iteración.

### 6.1.1 Iteración en todas partes

Muchos objetos diferentes admiten la iteración.

```python
a = 'hello'
for c in a: # cicla sobre los caracteres en a
    ...

b = { 'name': 'Dave', 'password':'foo'}
for k in b: # cicla sobre las claves del diccionario
    ...

c = [1,2,3,4]
for i in c: # cicla sobre los elementos en una lista/tupla
    ...

f = open('foo.txt')
for x in f: # cicla sobre las lineas en un archivo
    ...
```

### 6.1.2 Iteración: Protocolo

Considere la forafirmación.

```python
for x in obj:
    # declaraciones
```

¿Qué pasa debajo del capó?

```python
_iter = obj.__iter__()        # consigue el objeto iterador
while True:
    try:
        x = _iter.__next__()  # consigue el próximo elemento
        # statements ...
    except StopIteration:     # no hay más elementos
        break
```

Todos los objetos que trabajan con el for-loopimplementan este protocolo de iteración de bajo nivel.

Ejemplo: iteración manual sobre una lista.

```python
>>> x = [1,2,3]
>>> iterador = x.__iter__()
>>> iterador
<listiterator object at 0x590b0>
>>> iterador.__next__()
1
>>> iterador.__next__()
2
>>> iterador.__next__()
3
>>> iterador.__next__()
Traceback (most recent call last):
File "<stdin>", line 1, in ? StopIteration
>>>
```

### 6.1.3 Apoyo a la iteración

Knowing about iteration is useful if you want to add it to your own objects. For example, making a custom container.

```python
class Portfolio:
    def __init__(self):
        self.holdings = []

    def __iter__(self):
        return self.holdings.__iter__()
    ...

port = Portfolio()
for s in port:
    ...
```

### 6.1.4 Ejercicios
#### Ejercicio 6.1: Iteración ilustrada

Crea la siguiente lista:

a = [1,9,4,25,16]

Repetir manualmente esta lista. Llame `__iter__()` para obtener un iterador y llame al método `__next__()` para obtener elementos sucesivos.

```python
>>> i = a.__iter__()
>>> i
<listiterator object at 0x64c10>
>>> i.__next__()
1
>>> i.__next__()
9
>>> i.__next__()
4
>>> i.__next__()
25
>>> i.__next__()
16
>>> i.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>
```

La función `next()` incorporada es un atajo para llamar al método `__next__()` de un iterador. Intente usarlo en un archivo:

```python
>>> f = open('Data/portfolio.csv')
>>> f.__iter__()  # Nota: Esto retorna el archivo mismo <_io.TextIOWrapper name='Data/portfolio.csv' mode='r' encoding='UTF-8'>
>>> next(f)
'name,shares,price\n'
>>> next(f)
'"AA",100,32.20\n'
>>> next(f)
'"IBM",50,91.10\n'
>>>
```

Sigue llamando `next(f)` hasta que llegues al final del archivo. Mira lo que pasa.

#### Ejercicio 6.2: Apoyo a la iteración

En ocasiones, es posible que desee hacer que uno de sus propios objetos admita la iteración, especialmente si su objeto se ajusta a una lista existente u otra iterable. En un archivo nuevo `portfolio.py`, defina la siguiente clase:

```python
# portfolio.py
class Portfolio:

    def __init__(self, holdings):
        self._holdings = holdings

    @property
    def total_cost(self):
        return sum([s.cost for s in self._holdings])

    def tabulate_shares(self):
        from collections import Counter
        total_shares = Counter()
        for s in self._holdings:
            total_shares[s.name] += s.shares
        return total_shares
```

Esta clase está destinada a ser una capa alrededor de una lista, pero con algunos métodos adicionales como la total_costpropiedad. Modifique la función `read_portfolio()` en `report.py` para que cree una instancia de `Portfolio` como esta:

```python
# report.py
...

import fileparse
from stock import Stock
from portfolio import Portfolio

def read_portfolio(filename):
    '''
    Read a stock portfolio file into a list of dictionaries with keys
    name, shares, and price.
    '''
    with open(filename) as file:
        portdicts = fileparse.parse_csv(file,
                                        select=['name','shares','price'],
                                        types=[str,int,float])

    portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ]
    return Portfolio(portfolio)
...
```

Intente ejecutar el report.pyprograma. Descubrirá que falla espectacularmente debido al hecho de que las Portfolioinstancias no son iterables.

```python
>>> import report
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
... falla ...
```

Solucione esto modificando la Portfolioclase para admitir la iteración:

```python
class Portfolio:

    def __init__(self, holdings):
        self._holdings = holdings

    def __iter__(self):
        return self._holdings.__iter__()

    @property
    def total_cost(self):
        return sum([s.shares*s.price for s in self._holdings])

    def tabulate_shares(self):
        from collections import Counter
        total_shares = Counter()
        for s in self._holdings:
            total_shares[s.name] += s.shares
        return total_shares
```

Una vez que haya realizado este cambio, su report.pyprograma debería funcionar nuevamente. Mientras lo hace, arregle su programa `pcost.py` para usar el nuevo objeto `Portfolio`. Me gusta esto:

```python
# pcost.py
import report

def portfolio_cost(filename):
    ''' Computes the total cost (shares*price) of a portfolio file '''
    portfolio = report.read_portfolio(filename)
    return portfolio.total_cost
```

Pruébelo para asegurarse de que funcione:

```python
>>> import pcost
>>> pcost.portfolio_cost('Data/portfolio.csv')
44671.15
>>>
```

#### Ejercicio 6.3: Hacer un recipiente más adecuado

Si crea una clase de contenedor, a menudo desea hacer más que solo iterar. Modifique la Portfolioclase para que tenga otros métodos especiales como este:

```python
class Portfolio:
    def __init__(self, holdings):
        self._holdings = holdings

    def __iter__(self):
        return self._holdings.__iter__()

    def __len__(self):
        return len(self._holdings)

    def __getitem__(self, index):
        return self._holdings[index]

    def __contains__(self, name):
        return any([s.name == name for s in self._holdings])

    @property
    def total_cost(self):
        return sum([s.shares*s.price for s in self._holdings])

    def tabulate_shares(self):
        from collections import Counter
        total_shares = Counter()
        for s in self._holdings:
            total_shares[s.name] += s.shares
        return total_shares
```

Ahora, pruebe algunos experimentos con esta nueva clase:

```python
>>> import report
>>> portfolio = report.read_portfolio('Data/portfolio.csv')
>>> len(portfolio)
7
>>> portfolio[0]
Stock('AA', 100, 32.2)
>>> portfolio[1]
Stock('IBM', 50, 91.1)
>>> portfolio[0:3]
[Stock('AA', 100, 32.2), Stock('IBM', 50, 91.1), Stock('CAT', 150, 83.44)]
>>> 'IBM' in portfolio
True
>>> 'AAPL' in portfolio
False
>>>
```

Una observación importante acerca de esto: generalmente, el código se considera “Pythonic” si habla el vocabulario común de cómo funcionan normalmente otras partes de Python. Para los objetos de contenedor, el soporte de iteración, indexación, contención y otros tipos de operadores es una parte importante de esto.

## 6.2 Personalización de la iteración con generadores

Esta sección analiza cómo se puede personalizar la iteración utilizando una función de generador.

### 6.2.1 Un problema

Suponga que desea crear su propio patrón de iteración personalizado.

Por ejemplo, una cuenta atrás.

```python
>>> for x in countdown(10):
...   print(x, end=' ')
...
10 9 8 7 6 5 4 3 2 1
>>>
```

Hay una forma sencilla de hacer esto.

### 6.2.2 Generadores

Un generador es una función que define la iteración.

```python
def countdown(n):
    while n > 0:
        yield n
        n -= 1
```

Por ejemplo:

```python
>>> for x in countdown(10):
...   print(x, end=' ')
...
10 9 8 7 6 5 4 3 2 1
>>>
```

Un generador es cualquier función que usa la declaración `yield`.

El comportamiento de los generadores es diferente al de una función normal. Llamar a una función generadora crea un objeto generador. No ejecuta la función de inmediato.

```python
def countdown(n):
    # agregando sdeclaracion de impresion
    print('Cuenta hacia abajo desde', n)
    while n > 0:
        yield n
        n -= 1
```

```python
>>> x = countdown(10)
# There is NO PRINT STATEMENT
>>> x
# x is a generator object
<generator object at 0x58490>
>>>
```

La función solo se ejecuta en llamada a `__next__()`.

```python
>>> x = countdown(10)
>>> x
<generator object at 0x58490>
>>> x.__next__()
Counting down from 10
10
>>>
```

`yield` produce un valor, pero suspende la ejecución de la función. La función se reanuda en la próxima llamada a `__next__()`.

```python
>>> x.__next__()
9
>>> x.__next__()
8
```

Cuando el generador finalmente regresa, la iteración genera un error.

```python
>>> x.__next__()
1
>>> x.__next__()
Traceback (most recent call last):
File "<stdin>", line 1, in ? StopIteration
>>>
```

*Observación: Una función generadora implementa el mismo protocolo de bajo nivel que las declaraciones for usan en listas, tuplas, dictados, archivos, etc.*

### 6.2.3 Ejercicios

#### Ejercicio 6.4: Un generador simple

Si alguna vez desea personalizar la iteración, siempre debe pensar en las funciones del generador. Son fáciles de escribir: cree una función que lleve a cabo la lógica de iteración deseada y utilíce `yield` para emitir valores.

Por ejemplo, pruebe este generador que busca en un archivo líneas que contengan una subcadena coincidente:

```python
>>> def filematch(filename, substr):
        with open(filename, 'r') as f:
            for line in f:
                if substr in line:
                    yield line

>>> for line in open('Data/portfolio.csv'):
        print(line, end='')

name,shares,price
"AA",100,32.20
"IBM",50,91.10
"CAT",150,83.44
"MSFT",200,51.23
"GE",95,40.37
"MSFT",50,65.10
"IBM",100,70.44
>>> for line in filematch('Data/portfolio.csv', 'IBM'):
        print(line, end='')

"IBM",50,91.10
"IBM",100,70.44
>>>
```

Esto es algo interesante: la idea de que puede ocultar un montón de procesamiento personalizado en una función y usarlo para alimentar un ciclo `for`. El siguiente ejemplo analiza un caso más inusual.

#### Ejercicio 6.5: Supervisión de una fuente de datos de transmisión

Los generadores pueden ser una forma interesante de monitorear fuentes de datos en tiempo real, como archivos de registro o feeds del mercado de valores. En esta parte, exploraremos esta idea. Para comenzar, siga cuidadosamente las siguientes instrucciones.

El programa Data/stocksim.pyes un programa que simula datos del mercado de valores. Como salida, el programa escribe constantemente datos en tiempo real en un archivo Data/stocklog.csv. En una ventana de comando separada, vaya al Data/directorio y ejecute este programa:

bash % python3 stocksim.py

Si está en Windows, simplemente ubique el stocksim.pyprograma y haga doble clic en él para ejecutarlo. Ahora, olvídese de este programa (déjelo correr). Usando otra ventana, mire el archivo que Data/stocklog.csvestá escribiendo el simulador. Debería ver que se agregan nuevas líneas de texto al archivo cada pocos segundos. Nuevamente, deje que este programa se ejecute en segundo plano; se ejecutará durante varias horas (no debería tener que preocuparse por ello).

Una vez que el programa anterior se esté ejecutando, escribamos un pequeño programa para abrir el archivo, buscar el final y esperar una nueva salida. Cree un archivo follow.pyy coloque este código en él:

```python
# follow.py
import os
import time

f = open('Data/stocklog.csv')
f.seek(0, os.SEEK_END)   # Move file pointer 0 bytes from end of file
while True:
    line = f.readline()
    if line == '':
        time.sleep(0.1)   # Sleep briefly and retry
        continue
    fields = line.split(',')
    name = fields[0].strip('"')
    price = float(fields[1])
    change = float(fields[4])
    if change < 0:
        print(f'{name:>10s} {price:>10.2f} {change:>10.2f}')
```

Si ejecuta el programa, verá un indicador de cotización en tiempo real. Bajo el capó, este código es como el comando `tail -f` de Unix que se usa para ver un archivo de registro.

Nota: El uso del método `readline()` en este ejemplo es algo inusual en el sentido de que no es la forma habitual de leer líneas de un archivo (normalmente solo usaría un for-loop). Sin embargo, en este caso, lo estamos usando para sondear repetidamente el final del archivo para ver si se han agregado más datos (`readline()` devolverá nuevos datos o una cadena vacía).

#### Ejercicio 6.6: uso de un generador para producir datos

Si observa el código del ejercicio 6.5, la primera parte del código produce líneas de datos, mientras que las declaraciones al final del whileciclo consumen los datos. Una característica importante de las funciones del generador es que puede mover todo el código de producción de datos a una función reutilizable.

Modifique el código del ejercicio 6.5 para que la lectura del archivo sea realizada por una función generadora `follow(filename)`. Haga que funcione el siguiente código:

```python
>>> for line in follow('Data/stocklog.csv'):
          print(line, end='')

... Debería ver lineas de salida producidas aquí ...
```

Modifique el código de cotización bursátil para que se vea así:

```python
if __name__ == '__main__':
    for line in follow('Data/stocklog.csv'):
        fields = line.split(',')
        name = fields[0].strip('"')
        price = float(fields[1])
        change = float(fields[4])
        if change < 0:
            print(f'{name:>10s} {price:>10.2f} {change:>10.2f}')
```

#### Ejercicio 6.7: Observando tu portafolio

Modifique el programa `follow.py` para que observe el flujo de datos de acciones e imprima un ticker que muestre información solo para las acciones de una cartera. Por ejemplo:

```python


if __name__ == '__main__':
    import report

    portfolio = report.read_portfolio('Data/portfolio.csv')

    for line in follow('Data/stocklog.csv'):
        fields = line.split(',')
        name = fields[0].strip('"')
        price = float(fields[1])
        change = float(fields[4])
        if name in portfolio:
            print(f'{name:>10s} {price:>10.2f} {change:>10.2f}')
```

Nota: Para que esto funcione, su Portfolioclase debe ser compatible con el inoperador. Vea el ejercicio 6.3 y asegúrese de implementar el operador `__contains__()`.

### Discusión

Algo muy poderoso acaba de ocurrir aquí. Movió un patrón de iteración interesante (líneas de lectura al final de un archivo) a su propia pequeña función. La función `follow()` es ahora esta utilidad de propósito completamente general que puede usar en cualquier programa. Por ejemplo, puede usarlo para ver registros del servidor, registros de depuración y otras fuentes de datos similares. Eso es algo genial.

## 6.3 Productores, consumidores y oleoductos
### 6.3.1 Problemas entre productores y consumidores
### 6.3.2 Tuberías de generador
### 6.3.4 Ejercicios
#### Ejercicio 6.8: Configurar una canalización simple
#### Ejercicio 6.9: configurar una canalización más compleja
#### Ejercicio 6.10: creación de más componentes de canalización
#### Ejercicio 6.11: filtrado de datos
#### Ejercicio 6.12: Poniéndolo todo junto
### Discusión


## 6.4 Expresiones generadoras
### 6.4.1 Expresiones generadoras
### 6.4.2 ¿Por qué generadores?
### 6.4.3 El módulo `itertools`
### 6.4.4 Ejercicios
#### Ejercicio 6.13: Expresiones generadoras
#### Ejercicio 6.14: Expresiones generadoras en argumentos de funciones
#### Ejercicio 6.15: simplificación de código
