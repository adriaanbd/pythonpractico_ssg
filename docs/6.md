# 6. Generadores

La iteración es uno de los más comunes patrones de programación en Python. Los programas hacen mucha iteración para procesar listas, leer archivos, consultar una base de datos, y más. Una de las características mas poderosas de Python es la habilidad de costumizar y redefinir la iteración en una función generadora. Al final de la sección, escribiremos algunos programas que procesan datos en tiempo real en una manera interesante.
## 6.1 Protocolo de iteración

Esta sección analiza el proceso subyacente de iteración.

### 6.1.1 Iteración en todas partes

Muchos objetos diferentes admiten la iteración.

```python
a = 'hello'
for c in a: # cicla sobre los caracteres en a
    ...

b = { 'name': 'Dave', 'password':'foo'}
for k in b: # cicla sobre las claves del diccionario
    ...

c = [1,2,3,4]
for i in c: # cicla sobre los elementos en una lista/tupla
    ...

f = open('foo.txt')
for x in f: # cicla sobre las lineas en un archivo
    ...
```

### 6.1.2 Iteración: Protocolo

Considere la forafirmación.

```python
for x in obj:
    # declaraciones
```

¿Qué pasa debajo del capó?

```python
_iter = obj.__iter__()        # consigue el objeto iterador
while True:
    try:
        x = _iter.__next__()  # consigue el próximo elemento
        # statements ...
    except StopIteration:     # no hay más elementos
        break
```

Todos los objetos que trabajan con el for-loopimplementan este protocolo de iteración de bajo nivel.

Ejemplo: iteración manual sobre una lista.

```python
>>> x = [1,2,3]
>>> iterador = x.__iter__()
>>> iterador
<listiterator object at 0x590b0>
>>> iterador.__next__()
1
>>> iterador.__next__()
2
>>> iterador.__next__()
3
>>> iterador.__next__()
Traceback (most recent call last):
File "<stdin>", line 1, in ? StopIteration
>>>
```

### 6.1.3 Apoyo a la iteración

Knowing about iteration is useful if you want to add it to your own objects. For example, making a custom container.

```python
class Portfolio:
    def __init__(self):
        self.holdings = []

    def __iter__(self):
        return self.holdings.__iter__()
    ...

port = Portfolio()
for s in port:
    ...
```

### 6.1.4 Ejercicios
#### Ejercicio 6.1: Iteración ilustrada

Crea la siguiente lista:

a = [1,9,4,25,16]

Repetir manualmente esta lista. Llame `__iter__()` para obtener un iterador y llame al método `__next__()` para obtener elementos sucesivos.

```python
>>> i = a.__iter__()
>>> i
<listiterator object at 0x64c10>
>>> i.__next__()
1
>>> i.__next__()
9
>>> i.__next__()
4
>>> i.__next__()
25
>>> i.__next__()
16
>>> i.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>
```

La función `next()` incorporada es un atajo para llamar al método `__next__()` de un iterador. Intente usarlo en un archivo:

```python
>>> f = open('Data/portfolio.csv')
>>> f.__iter__()  # Nota: Esto retorna el archivo mismo <_io.TextIOWrapper name='Data/portfolio.csv' mode='r' encoding='UTF-8'>
>>> next(f)
'name,shares,price\n'
>>> next(f)
'"AA",100,32.20\n'
>>> next(f)
'"IBM",50,91.10\n'
>>>
```

Sigue llamando `next(f)` hasta que llegues al final del archivo. Mira lo que pasa.

#### Ejercicio 6.2: Apoyo a la iteración

En ocasiones, es posible que desee hacer que uno de sus propios objetos admita la iteración, especialmente si su objeto se ajusta a una lista existente u otra iterable. En un archivo nuevo `portfolio.py`, defina la siguiente clase:

```python
# portfolio.py
class Portfolio:

    def __init__(self, holdings):
        self._holdings = holdings

    @property
    def total_cost(self):
        return sum([s.cost for s in self._holdings])

    def tabulate_shares(self):
        from collections import Counter
        total_shares = Counter()
        for s in self._holdings:
            total_shares[s.name] += s.shares
        return total_shares
```

Esta clase está destinada a ser una capa alrededor de una lista, pero con algunos métodos adicionales como la total_costpropiedad. Modifique la función `read_portfolio()` en `report.py` para que cree una instancia de `Portfolio` como esta:

```python
# report.py
...

import fileparse
from stock import Stock
from portfolio import Portfolio

def read_portfolio(filename):
    '''
    Read a stock portfolio file into a list of dictionaries with keys
    name, shares, and price.
    '''
    with open(filename) as file:
        portdicts = fileparse.parse_csv(file,
                                        select=['name','shares','price'],
                                        types=[str,int,float])

    portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ]
    return Portfolio(portfolio)
...
```

Intente ejecutar el report.pyprograma. Descubrirá que falla espectacularmente debido al hecho de que las Portfolioinstancias no son iterables.

```python
>>> import report
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
... falla ...
```

Solucione esto modificando la Portfolioclase para admitir la iteración:

```python
class Portfolio:

    def __init__(self, holdings):
        self._holdings = holdings

    def __iter__(self):
        return self._holdings.__iter__()

    @property
    def total_cost(self):
        return sum([s.shares*s.price for s in self._holdings])

    def tabulate_shares(self):
        from collections import Counter
        total_shares = Counter()
        for s in self._holdings:
            total_shares[s.name] += s.shares
        return total_shares
```

Una vez que haya realizado este cambio, su report.pyprograma debería funcionar nuevamente. Mientras lo hace, arregle su programa `pcost.py` para usar el nuevo objeto `Portfolio`. Me gusta esto:

```python
# pcost.py
import report

def portfolio_cost(filename):
    ''' Computes the total cost (shares*price) of a portfolio file '''
    portfolio = report.read_portfolio(filename)
    return portfolio.total_cost
```

Pruébelo para asegurarse de que funcione:

```python
>>> import pcost
>>> pcost.portfolio_cost('Data/portfolio.csv')
44671.15
>>>
```

#### Ejercicio 6.3: Hacer un recipiente más adecuado

Si crea una clase de contenedor, a menudo desea hacer más que solo iterar. Modifique la Portfolioclase para que tenga otros métodos especiales como este:

```python
class Portfolio:
    def __init__(self, holdings):
        self._holdings = holdings

    def __iter__(self):
        return self._holdings.__iter__()

    def __len__(self):
        return len(self._holdings)

    def __getitem__(self, index):
        return self._holdings[index]

    def __contains__(self, name):
        return any([s.name == name for s in self._holdings])

    @property
    def total_cost(self):
        return sum([s.shares*s.price for s in self._holdings])

    def tabulate_shares(self):
        from collections import Counter
        total_shares = Counter()
        for s in self._holdings:
            total_shares[s.name] += s.shares
        return total_shares
```

Ahora, pruebe algunos experimentos con esta nueva clase:

```python
>>> import report
>>> portfolio = report.read_portfolio('Data/portfolio.csv')
>>> len(portfolio)
7
>>> portfolio[0]
Stock('AA', 100, 32.2)
>>> portfolio[1]
Stock('IBM', 50, 91.1)
>>> portfolio[0:3]
[Stock('AA', 100, 32.2), Stock('IBM', 50, 91.1), Stock('CAT', 150, 83.44)]
>>> 'IBM' in portfolio
True
>>> 'AAPL' in portfolio
False
>>>
```

Una observación importante acerca de esto: generalmente, el código se considera “Pythonic” si habla el vocabulario común de cómo funcionan normalmente otras partes de Python. Para los objetos de contenedor, el soporte de iteración, indexación, contención y otros tipos de operadores es una parte importante de esto.

## 6.2 Personalización de la iteración con generadores
### 6.2.1 Un problema
### 6.2.2 Generadores
### 6.2.3 Ejercicios
#### Ejercicio 6.4: Un generador simple
#### Ejercicio 6.5: Supervisión de una fuente de datos de transmisión
#### Ejercicio 6.6: uso de un generador para producir datos
#### Ejercicio 6.7: Observando tu portafolio
### Discusión


## 6.3 Productores, consumidores y oleoductos
### 6.3.1 Problemas entre productores y consumidores
### 6.3.2 Tuberías de generador
### 6.3.4 Ejercicios
#### Ejercicio 6.8: Configurar una canalización simple
#### Ejercicio 6.9: configurar una canalización más compleja
#### Ejercicio 6.10: creación de más componentes de canalización
#### Ejercicio 6.11: filtrado de datos
#### Ejercicio 6.12: Poniéndolo todo junto
### Discusión


## 6.4 Expresiones generadoras
### 6.4.1 Expresiones generadoras
### 6.4.2 ¿Por qué generadores?
### 6.4.3 El módulo `itertools`
### 6.4.4 Ejercicios
#### Ejercicio 6.13: Expresiones generadoras
#### Ejercicio 6.14: Expresiones generadoras en argumentos de funciones
#### Ejercicio 6.15: simplificación de código
