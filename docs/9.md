# Paquetes

Concluiremos el curso con algunos detalles para la organización de código en paquetes. Además, discutiremos sobre la instalación de paquetes de terceros y sobre la preparación necesaria para entregarle nuestro código a otros. El tema de empaquetamiento de código essta en constante evolución y es una parte compleja en el desarrollo de Python. Por tanto, esta sección esta enfocada en compartir algunos principios de organización general de código.

## 9.1 Paquetes

Si está escribiendo un programa más grande, realmente no desea organizarlo como una gran colección de archivos independientes en el nivel superior. Esta sección presenta el concepto de paquete.

### 9.1.1 Módulos

Cualquier archivo fuente de Python es un módulo.

```python
# foo.py
def grok(a):
    ...
def spam(b):
    ...
```

Una declaración import carga y ejecuta un módulo.

```python
# program.py
import foo

a = foo.grok(2)
b = foo.spam('Hello')
...
```

### Paquetes vs Módulos

Para colecciones más grandes de código, es común organizar los módulos en un paquete.

```code
# From this
pcost.py
report.py
fileparse.py
```

```code
# To this
porty/
    __init__.py
    pcost.py
    report.py
    fileparse.py
```

Elige un nombre y crea un directorio de nivel superior. `porty` en el ejemplo anterior (claramente elegir este nombre es el primer paso más importante).

Agregue un archivo `__init__.py` al directorio. Puede estar vacío.

Coloque sus archivos de origen en el directorio.

### Usando un paquete

Un paquete sirve como espacio de nombres para las importaciones.

Esto significa que ahora hay importaciones multinivel.

```python
import porty.report
port = porty.report.read_portfolio('port.csv')
```

Hay otras variaciones de declaraciones de importación.

```python
from porty import report
port = report.read_portfolio('portfolio.csv')

from porty.report import read_portfolio
port = read_portfolio('portfolio.csv')
```

Dos problemas

Hay dos problemas principales con este enfoque.

* importa entre archivos en el mismo paquete.
* Scripts principales colocados dentro del paquete.

Entonces, básicamente todo se rompe. Pero, aparte de eso, funciona.

### Problema: Importaciones

Las importaciones entre archivos en el mismo paquete ahora deben incluir el nombre del paquete en la importación . Recuerda la estructura.

```
porty/
    __init__.py
    pcost.py
    report.py
    fileparse.py
```

Ejemplo de importación modificado.

```python
# report.py
from porty import fileparse

def read_portfolio(filename):
    return fileparse.parse_csv(...)
```

Todas las importaciones son absolutas, no relativas.

```
# report.py
import fileparse    # Se ROMPE. fileparse not found
...
```

### Importaciones relativas

En lugar de usar directamente el nombre del paquete, puede usar `.` para hacer referencia al paquete actual.

```python
# report.py
from . import fileparse

def read_portfolio(filename):
    return fileparse.parse_csv(...)
```

Sintaxis:

```python
from . import modname
```

Esto facilita el cambio de nombre del paquete.

### Problema: guiones principales

La ejecución de un submódulo de paquete como un script principal se rompe.

```code
bash $ python porty/pcost.py # BREAKS
...
```

Motivo: está ejecutando Python en un solo archivo y Python no ve el resto de la estructura del paquete correctamente (`sys.path` es incorrecto).

Todas las importaciones se rompen. Para solucionar este problema, debe ejecutar su programa de una manera diferente, usando la opción `-m`.

```code
bash $ python -m porty.pcost # WORKS
...
```

### archivos `__init__.py`

El propósito principal de estos archivos es unir módulos.

Ejemplo: consolidar funciones

```python
# porty/__init__.py
from .pcost import portfolio_cost
from .report import portfolio_report
```

Esto hace que los nombres aparezcan en el nivel superior al importar.

```python
from porty import portfolio_cost
portfolio_cost('portfolio.csv')
```

En lugar de utilizar las importaciones multinivel.

```python
from porty import pcost
pcost.portfolio_cost('portfolio.csv')
```

### Otra solución para scripts

Como se señaló, ahora debe usar `-m paqute.modulo` para ejecutar scripts dentro de su paquete.

```
bash % python3 -m porty.pcost portfolio.csv
```

Hay otra alternativa: escriba un nuevo script de nivel superior.

```python
#!/usr/bin/env python3
# pcost.py
import porty.pcost
import sys
porty.pcost.main(sys.argv)
```

Este script vive fuera del paquete. Por ejemplo, mirando la estructura del directorio:

```
pcost.py       # guion de nviel superior
porty/         # directorio del paquete
    __init__.py
    pcost.py
    ...
```

### Estructura de la aplicación

La organización del código y la estructura de archivos es clave para el mantenimiento de una aplicación.

No existe un enfoque de "talla única" para Python. Sin embargo, una estructura que funciona para muchos problemas es algo como esto.

```
porty-app/
  README.txt
  script.py         # SCRIPT
  porty/
    # codigo de la biblioteca / libreria
    __init__.py
    pcost.py
    report.py
    fileparse.py
```

El nivel superior `porty-app` es un contenedor para todo lo demás: documentación, scripts de nivel superior, ejemplos, etc.

Nuevamente, los scripts de nivel superior (si los hay) deben existir fuera del paquete de código. Un nivel más.

```python
#!/usr/bin/env python3
# porty-app/script.py
import sys
import porty

porty.report.main(sys.argv)
```

### Ejercicios

En este punto, tiene un directorio con varios programas:

```
pcost.py          # computes portfolio cost
report.py         # Makes a report
ticker.py         # Produce a real-time stock ticker
```

Hay una variedad de módulos de soporte con otras funcionalidades:

```
stock.py          # Stock class
portfolio.py      # Portfolio class
fileparse.py      # CSV parsing
tableformat.py    # Formatted tables
follow.py         # Follow a log file
typedproperty.py  # Typed class properties
```

En este ejercicio, vamos a limpiar el código y ponerlo en un paquete común.

### Ejercicio 9.1: Hacer un paquete simple

Cree un directorio llamado porty/y coloque todos los archivos de Python anteriores en él. Además, cree un __init__.pyarchivo vacío y colóquelo en el directorio. Debería tener un directorio de archivos como este:

```shell
porty/
    __init__.py
    fileparse.py
    follow.py
    pcost.py
    portfolio.py
    report.py
    stock.py
    tableformat.py
    ticker.py
    typedproperty.py
```

Elimina el archivo `__pycache__` que está en tu directorio. Este contiene módulos de Python precompilados de antes. Queremos empezar de nuevo.

Intente importar algunos de los módulos del paquete:

```python
>>> import porty.report
>>> import porty.pcost
>>> import porty.ticker
```

Si estas importaciones fallan, vaya al archivo apropiado y corrija las importaciones del módulo para incluir una importación relativa al paquete. Por ejemplo, una declaración como `import fileparse` podría cambiar a lo siguiente:

```python
# report.py
from . import fileparse
...
```

Si tiene una declaración como from fileparse import parse_csv, cambie el código a lo siguiente:

```python
# report.py
from .fileparse import parse_csv
...
```

#### Ejercicio 9.2: Crear un directorio de aplicaciones

Poner todo su código en un "paquete" no suele ser suficiente para una aplicación. A veces hay archivos de apoyo, documentación, scripts y otras cosas. Estos archivos deben existir FUERA del directorio `porty/` que creó anteriormente.

Cree un nuevo directorio llamado porty-app. Mueva el portydirectorio que creó en el ejercicio 9.1 a ese directorio. Copie los archivos de prueba `Data/portfolio.csv` y `Data/prices.csv` en este directorio. Además, cree un archivo `README.txt` con información sobre usted. Su código ahora debería estar organizado de la siguiente manera:

```shell
porty-app/
    portfolio.csv
    prices.csv
    README.txt
    porty/
        __init__.py
        fileparse.py
        follow.py
        pcost.py
        portfolio.py
        report.py
        stock.py
        tableformat.py
        ticker.py
        typedproperty.py
```

Para ejecutar su código, debe asegurarse de estar trabajando en el directorio `porty-app/` de nivel superior . Por ejemplo, desde la terminal:

```
shell % cd porty-app
shell % python3
>>> import porty.report
>>>
```

Intente ejecutar algunos de sus scripts anteriores como programa principal:

```shell
shell % cd porty-app
shell % python3 -m porty.report portfolio.csv prices.csv txt
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84

shell %
```

#### Ejercicio 9.3: Scripts de nivel superior

Usar el comando `python -m` suele ser un poco extraño. Es posible que desee escribir un script de nivel superior que simplemente se ocupe de las rarezas de los paquetes. Cree un script `print-report.py` que produzca el informe anterior:

```python
#!/usr/bin/env python3
# print-report.py
import sys
from porty.report import main
main(sys.argv)
```

Coloque este script en el directorio `porty-app/` de nivel superior. Asegúrese de poder ejecutarlo en esa ubicación:

```shell
shell % cd porty-app
shell % python3 print-report.py portfolio.csv prices.csv txt
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84

shell %
```

Su código final ahora debería estar estructurado de esta manera:

```shell
porty-app/
    portfolio.csv
    prices.csv
    print-report.py
    README.txt
    porty/
        __init__.py
        fileparse.py
        follow.py
        pcost.py
        portfolio.py
        report.py
        stock.py
        tableformat.py
        ticker.py
        typedproperty.py
```

## 9.2 Módulos de terceros
## 9.3 Dar su código a otros
