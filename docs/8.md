# 8. Prueba y Depuración

Esta sección introduce unos temás básicas en relación a pruebas, reportería y depuración.

*Nota: estaremos publicando el contenido de este módulo próximamente a más tardar el 1 de febrero.*


## 8.1 Prueba


### 8.1.1 Probando rocas, la depuración apesta

La naturaleza dinámica de Python hace que las pruebas sean de vital importancia para la mayoría de las aplicaciones. No hay un compilador para encontrar sus errores. La única forma de encontrar errores es ejecutar el código y asegurarse de probar todas sus funciones.

### 8.1.2 Afirmaciones

La assertdeclaración es una verificación interna del programa. Si una expresión no es verdadera, genera una AssertionErrorexcepción.

`assert` sintaxis de declaración.

```python
assert <expression> [, 'Diagnostic message']
```

Por ejemplo.

```python
assert isinstance(10, int), 'Expected int'
```

No debe usarse para verificar la entrada del usuario (es decir, datos ingresados ​​en un formulario web o algo así). Su propósito es más para controles internos e invariantes (condiciones que siempre deben ser verdaderas).

### 8.1.3 Programación por contrato

También conocido como Diseño por contrato, el uso liberal de afirmaciones es un enfoque para diseñar software. Prescribe que los diseñadores de software deben definir especificaciones de interfaz precisas para los componentes del software.

Por ejemplo, puede poner aserciones en todas las entradas de una función.

```python
def add(x, y):
    assert isinstance(x, int), 'Expected int'
    assert isinstance(y, int), 'Expected int'
    return x + y
```

La verificación de las entradas detectará inmediatamente a las personas que llaman que no estén usando los argumentos adecuados.

```python
>>> add(2, 3)
5
>>> add('2', '3')
Traceback (most recent call last):
...
AssertionError: Expected int
>>>
```

### 8.1.4 Pruebas en línea

Las afirmaciones también se pueden utilizar para pruebas sencillas.

```python
def add(x, y):
    return x + y

assert add(2,2) == 4
```

De esta manera, está incluyendo la prueba en el mismo módulo que su código.

Beneficio: si el código está claramente roto, los intentos de importar el módulo fallarán.

Esto no se recomienda para pruebas exhaustivas. Es más una "prueba de humo" básica. ¿La función funciona en algún ejemplo? Si no es así, definitivamente algo está roto.

### 8.1.5 Módulo `unittest`

Suponga que tiene algún código.

```python
# simple.py
def add(x, y):
    return x + y
```

Ahora, suponga que quiere probarlo. Cree un archivo de prueba separado como este.

```python
# test_simple.py
import simple
import unittest
```

Luego defina una clase de prueba.

```python
# test_simple.py
import simple
import unittest

# Notice that it inherits from unittest.TestCase
class TestAdd(unittest.TestCase):
    ...
```

La clase de prueba debe heredar `unittest.TestCase`.

En la clase de prueba, define los métodos de prueba.

```python
# test_simple.py
import simple
import unittest

# Notice that it inherits from unittest.TestCase
class TestAdd(unittest.TestCase):
    def test_simple(self):
        # Test with simple integer arguments         r = simple.add(2, 2)
        self.assertEqual(r, 5)
    def test_str(self):
        # Test with strings         r = simple.add('hello', 'world')
        self.assertEqual(r, 'helloworld')
```

*Importante: Cada método debe comenzar con test*.

### 8.1.6 Utilizando unittest

Hay varias afirmaciones integradas que vienen con unittest. Cada uno de ellos afirma algo diferente.

```python
# Assert that expr is True self.assertTrue(expr)

# Assert that x == y self.assertEqual(x,y)

# Assert that x != y self.assertNotEqual(x,y)

# Assert that x is near y self.assertAlmostEqual(x,y,places)

# Assert that callable(arg1,arg2,...) raises exc self.assertRaises(exc, callable, arg1, arg2, ...)
```

Esta no es una lista exhaustiva. Hay otras afirmaciones en el módulo.

### 8.1.7 Corriendo unittest

Para ejecutar las pruebas, convierta el código en un script.

```python
# test_simple.py
...

if __name__ == '__main__':
    unittest.main()
```

Luego, ejecute Python en el archivo de prueba.

```code
bash % python3 test_simple.py
F.
========================================================
FAIL: test_simple (__main__.TestAdd)
--------------------------------------------------------
Traceback (most recent call last):
  File "testsimple.py", line 8, in test_simple
    self.assertEqual(r, 5)
AssertionError: 4 != 5
--------------------------------------------------------
Ran 2 tests in 0.000s
FAILED (failures=1)
```

### 8.1.8 Comentario

Las pruebas unitarias efectivas son un arte y pueden volverse bastante complicadas para aplicaciones grandes.

El `unittest` módulo tiene una gran cantidad de opciones relacionadas con los corredores de pruebas, la recopilación de resultados y otros aspectos de las pruebas. Consulte la documentación para obtener más detalles.

### 8.1.9 Herramientas de prueba de terceros

El `unittest` módulo integrado tiene la ventaja de estar disponible en todas partes: es parte de Python. Sin embargo, a muchos programadores también les parece bastante detallado. Una alternativa popular es `pytest`. Con `pytest`, su archivo de prueba se simplifica a algo como lo siguiente:

```python
# test_simple.py import simple

def test_simple():
    assert simple.add(2,2) == 4

def test_str():
    assert simple.add('hello','world') == 'helloworld'
```

Para ejecutar las pruebas, simplemente escriba un comando como python -m pytest. Descubrirá todas las pruebas y las ejecutará.

Hay mucho más pytestque este ejemplo, pero por lo general es bastante fácil comenzar si decides probarlo.

### 8.1.10 Ejercicios

En este ejercicio, explorará la mecánica básica del uso del unittestmódulo de Python .

En ejercicios anteriores, escribió un archivo `stock.py` que contenía una clase `Stock`. Para este ejercicio, asumió que está usando el código escrito para el Ejercicio 7.9 que involucra propiedades con tipo. Si, por alguna razón, eso no funciona, es posible que desee copiar la solución desde `Solutions/7_9` su directorio de trabajo.

#### Ejercicio 8.1: Escritura de pruebas unitarias

En un archivo separado `test_stock.py`, escriba un conjunto de pruebas unitarias para la clase `Stock`. Para comenzar, aquí hay un pequeño fragmento de código que prueba la creación de instancias:

```python
# test_stock.py
import unittest
import stock

class TestStock(unittest.TestCase):
    def test_create(self):
        s = stock.Stock('GOOG', 100, 490.1)
        self.assertEqual(s.name, 'GOOG')
        self.assertEqual(s.shares, 100)
        self.assertEqual(s.price, 490.1)

if __name__ == '__main__':
    unittest.main()
```

Ejecute sus pruebas unitarias. Debería obtener una salida que se ve así:

```code
.
----------------------------------------------------------------------
Ran 1 tests in 0.000s

OK
```

Una vez que esté satisfecho de que funciona, escriba pruebas unitarias adicionales que verifiquen lo siguiente:

* Asegúrese de que la `s.cost` propiedad devuelva el valor correcto (`49010.0`)
* Asegúrese de que el `s.sell()` método funcione correctamente. Debería disminuir el valor de en `s.shares` consecuencia.
* Asegúrese de que el s.sharesatributo no se pueda establecer en un valor que no sea entero.

Para la última parte, deberá verificar que se genere una excepción. Una forma fácil de hacerlo es con un código como este:

```python
class TestStock(unittest.TestCase):
    ...
    def test_bad_shares(self):
         s = stock.Stock('GOOG', 100, 490.1)
         with self.assertRaises(TypeError):
             s.shares = '100'
```

## 8.2 Registro, manejo de errores y diagnóstico
## 8.3 Depuración
