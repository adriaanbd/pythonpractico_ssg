# 3. Organización de un Programa

En este modulo nos empapamos de más detalles sobre la composición de funciones, el manejo de errores y la introducción de modulos. Al final seremos capaces de escribir programas que son subdivididos en funciones esparcidas en varios archivos. Veremos algunas plantillas de código que les será útil para la creación de programas.

*Nota: estaremos publicando el contenido de este módulo a más tardar el 18 de enero.*

## 3.1 Scripting

En esta parte, veremos más de cerca la práctica de escribir scripts en Python.

### 3.1.1 ¿Qué es un guión / script?

Un script es un programa que ejecuta una serie de declaraciones y se detiene.

```python
# programa.py 
declaracion1
declaracion2
declaracion3
...
```

Hasta ahora, vale destacar que hemos estado escribiendo *scripts*.

### 3.1.2 Un problema

Si escribe un script útil, crecerá en características y funcionalidad. Es posible que desee aplicarlo a otros problemas relacionados. Con el tiempo, podría convertirse en una aplicación crítica. Sin embargo, podría convertirse en un gran enredado si no tiene cuidado. Entonces, es importante tener algún tipo de organización.

### 3.1.3 Definiendo cosas

Los nombres siempre deben definirse antes de que se utilicen más tarde.

```python
def square(x):
    return x*x

a = 42
b = a + 2     # requiere que `a` esté definida 
z = square(b) # require que `square` y `b` esten definidas 
```

El orden es importante. Casi siempre colocas las definiciones de variables y funciones cerca de la parte superior.

### 3.1.4 Definición de funciones

Es una buena idea poner todo el código relacionado con una sola tarea en un solo lugar. Para esto, haga uso de una función.

```python
def read_prices(filename):
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

Una función también simplifica las operaciones repetidas.

```python
oldprices = read_prices('oldprices.csv')
newprices = read_prices('newprices.csv')
```

### 3.1.5 ¿Qué es una función?

Una función es una secuencia de declaraciones con nombre.

```python
def funcname(args):
  declaracion
  declaracion
  ...
  return result
```

Cualquier declaración de Python se puede utilizar dentro.

```python
def foo():
    import math
    print(math.sqrt(2))
    help(math)
```

No hay declaraciones *especiales* en Python (lo que hace que sea fácil de recordar).

### 3.1.6 Definición de función

Las funciones se pueden definir en cualquier orden.

```python
def foo(x):
    bar(x)

def bar(x):
    declaracion

# OR 
def bar(x):
    declaracion

def foo(x):
    bar(x)
```

Las funciones solo deben definirse antes de ser utilizadas (o llamadas) durante la ejecución del programa.

```python
foo(3)        # foo debió haber estado definida 
```

Estilísticamente, probablemente sea más común ver las funciones definidas de abajo hacia arriba.

### 3.1.7 Estilo de abajo hacia arriba

Las funciones se tratan como bloques de construcción. Los bloques más pequeños / simples van primero.

```python
# myprogram.py def foo(x):
    ...

def bar(x):
    ...
    foo(x)          # Definida anteriormente
    ...

def spam(x):
    ...
    bar(x)          # Definida anteriormente
    ...

spam(42)            # Código que utiliza las funciones esta definido anteriormente 
```

Las funciones posteriores se basan en funciones anteriores. Nuevamente, esto es solo una cuestión de estilo. Lo único que importa en el programa anterior es que la llamada `spam(42)` sea ​​la última.

### 3.1.8 Diseño de funciones

Idealmente, las funciones deberían ser una caja negra . Solo deben operar con entradas pasadas y evitar variables globales y efectos secundarios misteriosos. Sus principales objetivos: **modularidad** y **previsibilidad**.

### 3.1.9 Documentación en cadenas

La documentación en cadenas, comunmente conocida en inglés como *doc strings*, es una buena práctica que incluye un breve resumen de una oración de lo que hace la función. Si se necesita más información, se incluye un breve ejemplo de uso junto con una descripción más detallada de los argumentos. Las mismas se escriben inmediatamente después del nombre de la función y alimentan a `help()`, el IDE (ambiente integrado de desarrollo) y otras herramientas.

```python
def read_prices(filename):
    ''' Read prices from a CSV file of name,price data '''
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

### 3.1.10 Tipo de anotaciones

También puede agregar sugerencias de tipo opcionales a las definiciones de funciones.

```python
def read_prices(filename: str) -> dict:
    '''Lee precios de un archivo CSV file de nombre, precio, y data'''
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

Las sugerencias no hacen nada operativamente. Son puramente informativos. Sin embargo, pueden ser utilizados por IDE, verificadores de código y otras herramientas para hacer más.

### 3.1.11 Ejercicios

En la sección 2, escribió un programa llamado report.pyque imprimía un informe que mostraba el rendimiento de una cartera de acciones. Este programa constaba de algunas funciones. Por ejemplo:

```python
# report.py 
import csv

def read_portfolio(filename):
    '''Lee un archivo de cartera de acciones en una lista de diccionarios con la clave siendo nombre, acciones y precio.'''
    portfolio = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)

        for row in rows:
            record = dict(zip(headers, row))
            stock = {
                'name' : record['name'],
                'shares' : int(record['shares']),
                'price' : float(record['price'])
            }
            portfolio.append(stock)
    return portfolio
...
```

Sin embargo, también hubo partes del programa que solo realizaron una serie de cálculos con guión. Este código apareció cerca del final del programa. Por ejemplo:

```python
...

# Salida/output del reporte
headers = ('Name', 'Shares', 'Price', 'Change')
print('%10s %10s %10s %10s'  % headers)
print(('-' * 10 + ' ') * len(headers))
for row in report:
    print('%10s %10d %10.2f %10.2f' % row)
...
```

En este ejercicio, tomaremos el programa anterior y lo organizaremos con un poco más de fuerza en torno al uso de funciones.

#### Ejercicio 3.1: Estructurar un programa como una colección de funciones

Modifique su programa `report.py` para que todas las operaciones principales, incluyendo los cálculos y la salida, se lleven a cabo mediante una colección de funciones. 

Específicamente:

* Cree una función `print_report(report)` que imprima el informe.
* Cambie la última parte del programa para que no sea más que una serie de llamadas a funciones y ningún otro cálculo.

#### Ejercicio 3.2: Creación de una función de nivel superior para la ejecución del programa

Tome la última parte de su programa y empaquelo en una sola función `portfolio_report(portfolio_filename, prices_filename)`. Haga que la función funcione para que la siguiente llamada de función cree el informe como antes:

`portfolio_report('Data/portfolio.csv', 'Data/prices.csv')`

En esta versión final, su programa no será más que una serie de definiciones de funciones seguidas de una única llamada de función `portfolio_report()` final al (que ejecuta todos los pasos involucrados en el programa).

Al convertir su programa en una sola función, es fácil ejecutarlo en diferentes entradas. Por ejemplo, pruebe estas declaraciones de forma interactiva después de ejecutar su programa:

```python
>>> portfolio_report('Data/portfolio2.csv', 'Data/prices.csv')
>>> # mire la salida de la linea anterior
>>> files = ['Data/portfolio.csv', 'Data/portfolio2.csv']
>>> for name in files:
        print(f'{name:-^43s}')
        portfolio_report(name, 'Data/prices.csv')
        print()

>>> # mire del ciclo anterior
>>>
```

### Comentario

Python hace que sea muy fácil escribir código de *scripting* relativamente no estructurado en el que solo tiene un archivo con una secuencia de declaraciones. En el panorama general, casi siempre es mejor utilizar funciones cuando pueda. En algún momento, ese *script* crecerá y deseará tener un poco más de organización. Además, un hecho poco conocido es que Python se ejecuta un poco más rápido si usa funciones.