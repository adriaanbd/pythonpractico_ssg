# 3. Organización de un Programa

En este modulo nos empapamos de más detalles sobre la composición de funciones, el manejo de errores y la introducción de modulos. Al final seremos capaces de escribir programas que son subdivididos en funciones esparcidas en varios archivos. Veremos algunas plantillas de código que les será útil para la creación de programas.

*Nota: estaremos publicando el contenido de este módulo a más tardar el 18 de enero.*

## 3.1 Scripting

En esta parte, veremos más de cerca la práctica de escribir scripts en Python.

### 3.1.1 ¿Qué es un guión / script?

Un script es un programa que ejecuta una serie de declaraciones y se detiene.

```python
# programa.py 
declaracion1
declaracion2
declaracion3
...
```

Hasta ahora, vale destacar que hemos estado escribiendo *scripts*.

### 3.1.2 Un problema

Si escribe un script útil, crecerá en características y funcionalidad. Es posible que desee aplicarlo a otros problemas relacionados. Con el tiempo, podría convertirse en una aplicación crítica. Sin embargo, podría convertirse en un gran enredado si no tiene cuidado. Entonces, es importante tener algún tipo de organización.

### 3.1.3 Definiendo cosas

Los nombres siempre deben definirse antes de que se utilicen más tarde.

```python
def square(x):
    return x*x

a = 42
b = a + 2     # requiere que `a` esté definida 
z = square(b) # require que `square` y `b` esten definidas 
```

El orden es importante. Casi siempre colocas las definiciones de variables y funciones cerca de la parte superior.

### 3.1.4 Definición de funciones

Es una buena idea poner todo el código relacionado con una sola tarea en un solo lugar. Para esto, haga uso de una función.

```python
def read_prices(filename):
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

Una función también simplifica las operaciones repetidas.

```python
oldprices = read_prices('oldprices.csv')
newprices = read_prices('newprices.csv')
```

### 3.1.5 ¿Qué es una función?

Una función es una secuencia de declaraciones con nombre.

```python
def funcname(args):
  declaracion
  declaracion
  ...
  return result
```

Cualquier declaración de Python se puede utilizar dentro.

```python
def foo():
    import math
    print(math.sqrt(2))
    help(math)
```

No hay declaraciones *especiales* en Python (lo que hace que sea fácil de recordar).

### 3.1.6 Definición de función

Las funciones se pueden definir en cualquier orden.

```python
def foo(x):
    bar(x)

def bar(x):
    declaracion

# OR 
def bar(x):
    declaracion

def foo(x):
    bar(x)
```

Las funciones solo deben definirse antes de ser utilizadas (o llamadas) durante la ejecución del programa.

```python
foo(3)        # foo debió haber estado definida 
```

Estilísticamente, probablemente sea más común ver las funciones definidas de abajo hacia arriba.

### 3.1.7 Estilo de abajo hacia arriba

Las funciones se tratan como bloques de construcción. Los bloques más pequeños / simples van primero.

```python
# myprogram.py def foo(x):
    ...

def bar(x):
    ...
    foo(x)          # Definida anteriormente
    ...

def spam(x):
    ...
    bar(x)          # Definida anteriormente
    ...

spam(42)            # Código que utiliza las funciones esta definido anteriormente 
```

Las funciones posteriores se basan en funciones anteriores. Nuevamente, esto es solo una cuestión de estilo. Lo único que importa en el programa anterior es que la llamada `spam(42)` sea ​​la última.

### 3.1.8 Diseño de funciones

Idealmente, las funciones deberían ser una caja negra . Solo deben operar con entradas pasadas y evitar variables globales y efectos secundarios misteriosos. Sus principales objetivos: **modularidad** y **previsibilidad**.

### 3.1.9 Documentación en cadenas

La documentación en cadenas, comunmente conocida en inglés como *doc strings*, es una buena práctica que incluye un breve resumen de una oración de lo que hace la función. Si se necesita más información, se incluye un breve ejemplo de uso junto con una descripción más detallada de los argumentos. Las mismas se escriben inmediatamente después del nombre de la función y alimentan a `help()`, el IDE (ambiente integrado de desarrollo) y otras herramientas.

```python
def read_prices(filename):
    ''' Read prices from a CSV file of name,price data '''
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

### 3.1.10 Tipo de anotaciones

También puede agregar sugerencias de tipo opcionales a las definiciones de funciones.

```python
def read_prices(filename: str) -> dict:
    '''Lee precios de un archivo CSV file de nombre, precio, y data'''
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

Las sugerencias no hacen nada operativamente. Son puramente informativos. Sin embargo, pueden ser utilizados por IDE, verificadores de código y otras herramientas para hacer más.

### 3.1.11 Ejercicios

En la sección 2, escribió un programa llamado report.pyque imprimía un informe que mostraba el rendimiento de una cartera de acciones. Este programa constaba de algunas funciones. Por ejemplo:

```python
# report.py 
import csv

def read_portfolio(filename):
    '''Lee un archivo de cartera de acciones en una lista de diccionarios con la clave siendo nombre, acciones y precio.'''
    portfolio = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)

        for row in rows:
            record = dict(zip(headers, row))
            stock = {
                'name' : record['name'],
                'shares' : int(record['shares']),
                'price' : float(record['price'])
            }
            portfolio.append(stock)
    return portfolio
...
```

Sin embargo, también hubo partes del programa que solo realizaron una serie de cálculos con guión. Este código apareció cerca del final del programa. Por ejemplo:

```python
...

# Salida/output del reporte
headers = ('Name', 'Shares', 'Price', 'Change')
print('%10s %10s %10s %10s'  % headers)
print(('-' * 10 + ' ') * len(headers))
for row in report:
    print('%10s %10d %10.2f %10.2f' % row)
...
```

En este ejercicio, tomaremos el programa anterior y lo organizaremos con un poco más de fuerza en torno al uso de funciones.

#### Ejercicio 3.1: Estructurar un programa como una colección de funciones

Modifique su programa `report.py` para que todas las operaciones principales, incluyendo los cálculos y la salida, se lleven a cabo mediante una colección de funciones. 

Específicamente:

* Cree una función `print_report(report)` que imprima el informe.
* Cambie la última parte del programa para que no sea más que una serie de llamadas a funciones y ningún otro cálculo.

#### Ejercicio 3.2: Creación de una función de nivel superior para la ejecución del programa

Tome la última parte de su programa y empaquelo en una sola función `portfolio_report(portfolio_filename, prices_filename)`. Haga que la función funcione para que la siguiente llamada de función cree el informe como antes:

`portfolio_report('Data/portfolio.csv', 'Data/prices.csv')`

En esta versión final, su programa no será más que una serie de definiciones de funciones seguidas de una única llamada de función `portfolio_report()` final al (que ejecuta todos los pasos involucrados en el programa).

Al convertir su programa en una sola función, es fácil ejecutarlo en diferentes entradas. Por ejemplo, pruebe estas declaraciones de forma interactiva después de ejecutar su programa:

```python
>>> portfolio_report('Data/portfolio2.csv', 'Data/prices.csv')
>>> # mire la salida de la linea anterior
>>> files = ['Data/portfolio.csv', 'Data/portfolio2.csv']
>>> for name in files:
        print(f'{name:-^43s}')
        portfolio_report(name, 'Data/prices.csv')
        print()

>>> # mire del ciclo anterior
>>>
```

### Comentario

Python hace que sea muy fácil escribir código de *scripting* relativamente no estructurado en el que solo tiene un archivo con una secuencia de declaraciones. En el panorama general, casi siempre es mejor utilizar funciones cuando pueda. En algún momento, ese *script* crecerá y deseará tener un poco más de organización. Además, un hecho poco conocido es que Python se ejecuta un poco más rápido si usa funciones.

## 3.2 Más sobre funciones

Aunque las funciones se introdujeron antes, se proporcionaron muy pocos detalles sobre cómo funcionan realmente a un nivel más profundo. Esta sección tiene como objetivo llenar algunos vacíos y discutir asuntos como convenciones de llamadas, reglas de alcance y más.

### 3.2.1 Llamar a una función

Considere esta función:

```python
def read_prices(filename, debug):
    ...
```

Puede llamar a la función con argumentos posicionales:

```python
prices = read_prices('prices.csv', True)
```

O puede llamar a la función con argumentos de palabras clave:

```python
prices = read_prices(filename='prices.csv', debug=True)
```

### 3.2.2 Argumentos predeterminados

A veces quieres que un argumento sea opcional. Si es así, asigne un valor predeterminado en la definición de función.

```python
def read_prices(filename, debug=False):
    ...
```

Si se asigna un valor predeterminado, el argumento es opcional en las llamadas a funciones.

```python
d = read_prices('prices.csv')
e = read_prices('prices.dat', True)
```

*Nota: Los argumentos con valores predeterminados deben aparecer al final de la lista de argumentos (todos los argumentos no opcionales van primero).*

### 3.2.3 Prefiera argumentos de palabras clave vs argumentos opcionales

Compare y contraste estos dos estilos de llamadas diferentes:

```python
parse_data(data, False, True) # ????? 
parse_data(data, ignore_errors=True)
parse_data(data, debug=True)
parse_data(data, debug=True, ignore_errors=True)
```

En la mayoría de los casos, los argumentos de palabras clave mejoran la claridad del código, especialmente para argumentos que sirven como indicadores o que están relacionados con características opcionales.

### 3.2.4 Mejores prácticas de diseño

Siempre proporcione nombres cortos pero significativos a los argumentos de las funciones.

Alguien que use una función puede querer usar el estilo de llamada de palabras clave.

```python
d = read_prices('prices.csv', debug=True)
```

Las herramientas de desarrollo de Python mostrarán los nombres en las funciones de ayuda y la documentación.

### 3.2.5 Devolución de valores

La declaración `return` devuelve un valor

```python
def square(x):
    return x * x
```

Si no se proporciona ningún valor de retorno o el `return` falta, se devuelve `None`.

```python
def bar(x):
    ...declaraciones
    return

a = bar(4)      # a = None 

# Oe
def foo(x):
    ...declaraciones  # Sin `return` 

b = foo(4)      # b = None 
```

### 3.2.6 Múltiples valores de retorno

Las funciones solo pueden devolver un valor. Sin embargo, una función puede devolver varios valores devolviéndolos en una tupla.

```python
def divide(a,b):
    q = a // b      # Cociente     
    r = a % b       # Remanente     
    return q, r     # Retorna una tuple 
```

Ejemplo de uso:

```python
x, y = divide(37,5) # x = 7, y = 2 
x = divide(37, 5)   # x = (7, 2) 
```

### 3.2.7 Alcance de una variable

Los programas asignan valores a las variables.

```python
x = value # variable Global  
def foo():
    y = value # variable Local  
```

Las asignaciones de variables ocurren fuera y dentro de las definiciones de funciones. Las variables definidas en el exterior son "globales". Las variables dentro de una función son "locales".

### 3.2.8 Variables locales

Las variables asignadas dentro de las funciones son privadas.

```python
def read_portfolio(filename):
    portfolio = []
    for line in open(filename):
        fields = line.split(',')
        s = (fields[0], int(fields[1]), float(fields[2]))
        portfolio.append(s)
    return portfolio
```

En este ejemplo, `filename`, `portfolio`, `line`, `fields` y `s` son variables locales. Esas variables no se conservan ni se puede acceder a ellas después de la llamada a la función.

```shell
>>> stocks = read_portfolio('portfolio.csv')
>>> fields
Traceback (most recent call last):
File "<stdin>", line 1, in ?
NameError: name 'fields' is not defined
>>>
```

Los locales tampoco pueden entrar en conflicto con las variables que se encuentran en otros lugares.

### 3.2.9 Variables globales

Las funciones pueden acceder libremente a los valores de globales definidos en el mismo archivo.

```python
name = 'Dave'

def greeting():
    print('Hello', name)  # Usando `name` variable global
```

Sin embargo, las funciones no pueden modificar los globales:

```python
name = 'Dave'

def spam():
  name = 'Guido'

spam()
print(name) # prints 'Dave' 
```

*Recuerde: todas las asignaciones en funciones son locales.*

### 3.2.10 Modificar variables globales

Si debe modificar una variable global, debe declararla como tal.

```python
name = 'Dave'

def spam():
    global name
    name = 'Guido' # Changes the global name above 
```
La declaración `global` debe aparecer antes de su uso y la variable correspondiente debe existir en el mismo archivo que la función. Habiendo visto esto, sepa que se considera de mala forma. De hecho, trate de evitarlo `global` completo si puede. Si necesita una función para modificar algún tipo de estado fuera de la función, es mejor usar una clase en su lugar (más sobre esto más adelante).

### 3.2.11 Transferencia de argumentos

Cuando llama a una función, las variables de argumento son nombres que hacen referencia a los valores pasados. Estos valores NO son copias (consulte la sección 2.7). Si se pasan tipos de datos mutables (por ejemplo, listas, diccionarios), se pueden modificar en el lugar.

```python
def foo(items):
    items.append(42)    # Modifica el objeto de entrada 

a = [1, 2, 3]
foo(a)
print(a)                # [1, 2, 3, 42] 
```

*Punto clave: las funciones no reciben una copia de los argumentos de entrada.*

### 3.2.12 Reasignación vs modificación

Asegúrese de comprender la sutil diferencia entre modificar un valor y reasignar un nombre de variable.

```python
def foo(items):
    items.append(42)    # Modifica el objeto de entrada  

a = [1, 2, 3]
foo(a)
print(a)                # [1, 2, 3, 42] 

# VS 
def bar(items):
    items = [4,5,6]    # Reasigna variable local `items` a otro objeto 

b = [1, 2, 3]
bar(b)
print(b)                # [1, 2, 3] 
```

*Recordatorio: la asignación de variables nunca sobrescribe la memoria. El nombre simplemente está vinculado a un nuevo valor.*

### 3.2.13 Ejercicios

Este conjunto de ejercicios le permite implementar lo que es, quizás, la parte más poderosa y difícil del curso. Hay muchos pasos y muchos conceptos de ejercicios anteriores que se juntan todos a la vez. La solución final es solo de unas 25 líneas de código, pero tómese su tiempo y asegúrese de comprender cada parte.

Una parte central de su programa `report.py` se centra en la lectura de archivos CSV. Por ejemplo, la función `read_portfolio()` lee un archivo que contiene filas de datos de cartera y la función `read_prices()` lee un archivo que contiene filas de datos de precios. En ambas funciones, hay muchas partes "complicadas" de bajo nivel y características similares. Por ejemplo, ambos abren un archivo y lo envuelven con el módulo `csv` y ambos convierten varios campos en nuevos tipos.

Si estuvieses haciendo mucho análisis de archivos, probablemente queras limpiar algo de esto y hacerlo más general. Ese es nuestro objetivo.

Comience este ejercicio abriendo un archivo llamado `fileparse.py`. Aquí es donde estaremos haciendo nuestro trabajo.

#### Ejercicio 3.3: lectura de archivos CSV

Para empezar, centrémonos en el problema de leer un archivo CSV en una lista de diccionarios. En el archivo `fileparse.py`, defina una función que se vea así:

```python
# fileparse.py 
import csv

def parse_csv(filename):
    ''' Convierte un archivo CSV a una lista de registro '''
    with open(filename) as f:
        rows = csv.reader(f)

        headers = next(rows)  # Lee la primera fila con el encabezado
        records = []
        for row in rows:
            if not row:    # Omite filas sin data                 
            	continue
            record = dict(zip(headers, row))
            records.append(record)

    return records
```

Esta función lee un archivo CSV en una lista de diccionarios mientras oculta los detalles de la apertura del archivo, lo envuelve con el módulo `csv`, ignora las líneas en blanco, etc.

Pruébelo:

Sugerencia: `$ python3 -i fileparse.py`.

```shell
>>> portfolio = parse_csv('Data/portfolio.csv')
>>> portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]
>>>
```

Esto es bueno, excepto que no puede hacer ningún tipo de cálculo útil con los datos porque todo está representado como una cadena. Arreglaremos esto en breve, pero sigamos mejorandolo.

### Ejercicio 3.4: Creación de un selector de columnas

En muchos casos, solo le interesan las columnas seleccionadas de un archivo CSV, no todos los datos. Modifique la función `parse_csv()` para que, opcionalmente, permita que las columnas especificadas por el usuario se seleccionen de la siguiente manera:

```shell
>>> # Lea toda la data 
>>> portfolio = parse_csv('Data/portfolio.csv')
>>> portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]

>>> # Read only some of the data >>> shares_held = parse_csv('Data/portfolio.csv', select=['name','shares'])
>>> shares_held
[{'name': 'AA', 'shares': '100'}, {'name': 'IBM', 'shares': '50'}, {'name': 'CAT', 'shares': '150'}, {'name': 'MSFT', 'shares': '200'}, {'name': 'GE', 'shares': '95'}, {'name': 'MSFT', 'shares': '50'}, {'name': 'IBM', 'shares': '100'}]
>>>
```

En el ejercicio 2.23 se dio un ejemplo de selector de columnas. Sin embargo, aquí hay una forma de hacerlo:

```python
# fileparse.py 
import csv

def parse_csv(filename, select=None):
    ''' Convierte un archivo CSV file a una lista de registros '''
    with open(filename) as f:
        rows = csv.reader(f)

        # Read the file headers         
        headers = next(rows)

        # Si se proporcionó un selector de columna, busque los índices de las columnas especificadas.
        # También reduzca el conjunto de encabezados utilizados para los diccionarios resultantes   
        if select:
            indices = [headers.index(colname) for colname in select]
            headers = select
        else:
            indices = []

        records = []
        for row in rows:
            if not row:    # Omitir filas sin data                
            	continue
            # Filtrar la fila si se seleccionaron columnas específicas          
            if indices:
                row = [ row[index] for index in indices ]

            # Crear diccionario           
            record = dict(zip(headers, row))
            records.append(record)

    return records
```

Hay una serie de partes complicadas en esta parte. Probablemente lo más importante es el mapeo de las columnas seleccionadas a los índices de filas. Por ejemplo, suponga que el archivo de entrada tiene los siguientes encabezados:

```shell
>>> headers = ['name', 'date', 'time', 'shares', 'price']
>>>
```

Ahora, suponga que las columnas seleccionadas fueran las siguientes:

```shell
>>> select = ['name', 'shares']
>>>
```

Para realizar la selección adecuada, debe asignar los nombres de las columnas seleccionadas a los índices de las columnas en el archivo. Eso es lo que está haciendo este paso:

```shell
>>> indices = [headers.index(colname) for colname in select]
>>> indices
[0, 3]
>>>
```
En otras palabras, "nombre" es la columna `0` y "recursos compartidos" es la columna `3`. Cuando lee una fila de datos del archivo, los índices se utilizan para filtrarla:

```shell
>>> row = ['AA', '6/11/2007', '9:50am', '100', '32.20' ]
>>> row = [ row[index] for index in indices ]
>>> row
['AA', '100']
>>>
```

#### Ejercicio 3.5: Realización de conversión de tipos

Modifique la función `parse_csv()` para que, opcionalmente, permita que se apliquen conversiones de tipo a los datos devueltos. Por ejemplo:

```shell
>>> portfolio = parse_csv('Data/portfolio.csv', types=[str, int, float])
>>> portfolio
[{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}]

>>> shares_held = parse_csv('Data/portfolio.csv', select=['name', 'shares'], types=[str, int])
>>> shares_held
[{'name': 'AA', 'shares': 100}, {'name': 'IBM', 'shares': 50}, {'name': 'CAT', 'shares': 150}, {'name': 'MSFT', 'shares': 200}, {'name': 'GE', 'shares': 95}, {'name': 'MSFT', 'shares': 50}, {'name': 'IBM', 'shares': 100}]
>>>
```

Ya exploró esto en el ejercicio 2.24. Deberá insertar el siguiente fragmento de código en su solución:

```python
...
if types:
    row = [func(val) for func, val in zip(types, row) ]
...
```

#### Ejercicio 3.6: Trabajar sin encabezados

Algunos archivos CSV no incluyen información de encabezado. Por ejemplo, el archivo se prices.csvve así:

```csv
"AA",9.22
"AXP",24.85
"BA",44.85
"BAC",11.27
...
```
Modifique la `parse_csv()` función para que pueda trabajar con dichos archivos creando una lista de tuplas. Por ejemplo:

```shell
>>> prices = parse_csv('Data/prices.csv', types=[str,float], has_headers=False)
>>> prices
[('AA', 9.22), ('AXP', 24.85), ('BA', 44.85), ('BAC', 11.27), ('C', 3.72), ('CAT', 35.46), ('CVX', 66.67), ('DD', 28.47), ('DIS', 24.22), ('GE', 13.48), ('GM', 0.75), ('HD', 23.16), ('HPQ', 34.35), ('IBM', 106.28), ('INTC', 15.72), ('JNJ', 55.16), ('JPM', 36.9), ('KFT', 26.11), ('KO', 49.16), ('MCD', 58.99), ('MMM', 57.1), ('MRK', 27.58), ('MSFT', 20.89), ('PFE', 15.19), ('PG', 51.94), ('T', 24.79), ('UTX', 52.61), ('VZ', 29.26), ('WMT', 49.74), ('XOM', 69.35)]
>>>
```

Para realizar este cambio, deberá modificar el código para que la primera línea de datos no se interprete como una línea de encabezado. Además, deberá asegurarse de no crear diccionarios, ya que ya no hay nombres de columna para usar como claves.

### Ejercicio 3.7: elegir un delimitador de columna diferente

Aunque los archivos CSV son bastante comunes, también es posible que encuentre un archivo que use un separador de columna diferente, como una sangría (tab) o un espacio. Por ejemplo, el archivo se Data/portfolio.datve así:

```csv
name shares price
"AA" 100 32.20
"IBM" 50 91.10
"CAT" 150 83.44
"MSFT" 200 51.23
"GE" 95 40.37
"MSFT" 50 65.10
"IBM" 100 70.44
```

La función `csv.reader()` permite dar un delimitador de columna diferente de la siguiente manera:

rows = csv.reader(f, delimiter=' ')

Modifique su función `parse_csv()` para que también permita cambiar el delimitador.

Por ejemplo:

```shell
>>> portfolio = parse_csv('Data/portfolio.dat', types=[str, int, float], delimiter=' ')
>>> portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]
>>>
```

### Comentario

Si ha llegado hasta aquí, ha creado una agradable función de biblioteca que es realmente útil. Puede usarla para analizar archivos CSV arbitrarios, seleccionar columnas de interés, realizar conversiones de tipos, sin tener que preocuparse demasiado por el funcionamiento interno de los archivos o el csvmódulo.