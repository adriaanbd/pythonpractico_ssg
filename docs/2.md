# 2. Trabajando con data

Conoceremos las estructuras de datos de fundamental importancia en Python: tuples, lists, sets y dictionaries. Presentaremos algunos patrones comunes para el manejo de datos y discutiremos el modelo de objetos en Python.

## 2.1 Tipos y estructuras de data

Esta sección presenta estructuras de datos en forma de tuplas y diccionarios.

### 2.1.1 Tipos primitivos

Python tiene algunos tipos primitivos de datos:

* Enteros
* Números de punto flotante
* Cadenas (texto)

Aprendimos sobre esto en la introducción.

### 2.1.2 Tipo `None`

```python
email_address = None
```

`None` se utiliza a menudo como marcador de posición para un valor opcional o faltante. Eso se evalúa como "Falso" en condicionales.


```python
if email_address:
    send_email(email_address, msg)
```

### 2.1.3: Estructuras de data

Los programas reales tienen datos más complejos. Por ejemplo, información sobre una participación en acciones:

```code
100 acciones de GOOG a $490.10
```

Este es un "objeto" con tres partes:

* Nombre o símbolo de la acción ("GOOG", una cadena)
* Número de acciones (100, un número entero)
* Precio (490,10 un punto flotante)

### 2.1.4: Tuplas

Una tupla es una colección de valores agrupados.

Ejemplo:
```python
s = ('GOOG', 100, 490.1)
```

A veces el `()` es omitido.

```python
s = 'GOOG', 100, 490.1'
```

Casos especiales (0-tupla, 1-tupla).

```python
t = ()            # Una tupla vacía
w = ('GOOG', )    # Una tupla de 1-item
```

Las tuplas se utilizan a menudo para representar registros o estructuras *simples*. Normalmente, es un único *objeto* de varias partes.

Una buena analogía: *Una tupla es como una sola fila en una tabla de base de datos.*

El contenido de la tupla está ordenado (como una matriz).

```python
s = ('GOOG', 100, 490.1)
name = s[0]                 # 'GOOG'
shares = s[1]               # 100
price = s[2]                # 490.1
```

Sin embargo, el contenido no se puede modificar.

```python
>>> s[1] = 75
TypeError: object does not support item assignment
```

Sin embargo, puede crear una nueva tupla basada en una tupla actual.

```python
s = (s[0], 75, s[2])
```

Las tuplas tienen más que ver con empaquetar elementos relacionados en una sola *entidad*,
que con cualquier otra cosa.

```python
s = ('GOOG', 100, 490.1)
```

Por tanto, la tupla es fácil de pasar a otras partes de un programa como un solo objeto.

### 2.1.5: Desempaque de Tuplas

Para usar la tupla en otro lugar, puede desempaquetar sus partes en variables.

```python
name, shares, price = s
print('Cost', shares * price)
```

The number of variables on the left must match the tuple structure.

```python
name, shares = s     # ERROR
Traceback (most recent call last):
...
ValueError: too many values to unpack
```

### 2.1.6 Tuplas vs Listas

Tuples look like read-only lists. However, tuples are most often used
for a *single item* consisting of multiple parts.  Lists are usually a
collection of distinct items, usually all of the same type.

```python
record = ('GOOG', 100, 490.1)       # Una tupla que representa un registro en una cartera

symbols = [ 'GOOG', 'AAPL', 'IBM' ]  # Una lista que representa tres símbolos de acciones
```

### 2.1.7 Diccionarios

Un diccionario es la asignación de claves a valores. A veces también se le llama una tabla hash o matriz asociativa. Las claves sirven como índices para acceder a los valores.

```python
s = {
    'name': 'GOOG',
    'shares': 100,
    'price': 490.1
}
```

### 2.1.8 Operaciones comunes

To get values from a dictionary use the key names.

```python
>>> print(s['name'], s['shares'])
GOOG 100
>>> s['price']
490.10
>>>
```

Para agregar o modificar valores, asigne usando los nombres de las claves.

```python
>>> s['shares'] = 75
>>> s['date'] = '6/6/2007'
>>>
```

Para eliminar un valor, use la instrucción `del`.

```python
>>> del s['date']
>>>
```

### 2.1.9 ¿Porqué diccionarios?

Los diccionarios son útiles cuando hay * muchos * valores diferentes y esos valores
puede ser modificado o manipulado. Los diccionarios hacen que su código sea más legible.

```python
s['price']
# vs
s[2]
```

### 2.1.10 Ejercicios

En los últimos ejercicios, escribió un programa que lee un archivo de datos `Data/portfolio.csv`.
Usando el módulo `csv`, es fácil leer el archivo fila por fila.

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> next(rows)
['name', 'shares', 'price']
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>>
```

Aunque leer el archivo es fácil, a menudo querrá hacer más con el datos que leerlos.
Por ejemplo, tal vez desee almacenarlo y comience a realizar algunos cálculos sobre él. Desafortunadamente, una "fila" sin procesar de datos no le da suficiente para trabajar.
Por ejemplo, incluso un el cálculo matemático simple no funciona:

```python
>>> row = ['AA', '100', '32.20']
>>> cost = row[1] * row[2]
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: can't multiply sequence by non-int of type 'str'
>>>
```

Para hacer más, normalmente desea interpretar los datos sin procesar de alguna manera
y convertirlo en un tipo de objeto más útil para que pueda trabajar
con él más tarde. Dos opciones simples son tuplas o diccionarios.

#### Ejercicio 2.1: Tuplas

En el indicador interactivo, cree la siguiente tupla que represente la fila anterior, pero con las columnas numéricas convertidas a los números adecuados:

```python
>>> t = (row[0], int(row[1]), float(row[2]))
>>> t
('AA', 100, 32.2)
>>>
```

Con esto, ahora puede calcular el costo total multiplicando las acciones y el precio:

```python
>>> cost = t[1] * t[2]
>>> cost
3220.0000000000005
>>>
```

¿Las matemáticas están rotas en Python? ¿Cuál es el problema con la respuesta de
3220.0000000000005?

Este es un artefacto del hardware de punto flotante en su computadora que solo puede representar decimales con precisión en Base-2, no en Base-10. Incluso para cálculos simples que involucran decimales en base 10, se introducen pequeños errores. Esto es normal, aunque quizás un poco sorprendente si no lo ha visto antes.

Esto sucede en todos los lenguajes de programación que utilizan decimales de punto flotante, pero a menudo se oculta al imprimir. Por ejemplo:

```python
>>> print(f'{cost:0.2f}')
3220.00
>>>
```
Las tuplas son de solo lectura. Verifique esto intentando cambiar el número de acciones a 75.

```python
>>> t[1] = 75
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>>
```

Aunque no puede cambiar el contenido de la tupla, siempre puede crear una tupla completamente nueva que reemplace a la anterior.

```python
>>> t = (t[0], 75, t[2])
>>> t
('AA', 75, 32.2)
>>>
```

Siempre que reasigne un nombre de variable existente como este, el valor anterior se descarta. Aunque la asignación anterior puede parecer que está modificando la tupla, en realidad está creando una nueva tupla y desechando la anterior.

Las tuplas se utilizan a menudo para empaquetar y descomprimir valores en variables. Intente lo siguiente:

```python
>>> name, shares, price = t
>>> name
'AA'
>>> shares
75
>>> price
32.2
>>>
```
Tome las variables anteriores y vuelva a empaquetarlas en una tupla

```python
>>> t = (name, 2*shares, price)
>>> t
('AA', 150, 32.2)
>>>
```

#### Ejercicio 2.2: Diccionarios como estructura de datos

Una alternativa a una tupla es crear un diccionario.

```python
>>> d = {
        'name' : row[0],
        'shares' : int(row[1]),
        'price'  : float(row[2])
    }
>>> d
{'name': 'AA', 'shares': 100, 'price': 32.2 }
>>>
```

Calcule el costo total de esta participación:

```python
>>> cost = d['shares'] * d['price']
>>> cost
3220.0000000000005
>>>
```

Compare este ejemplo con el mismo cálculo que involucra tuplas anterior. Cambie el número de acciones a 75.

```python
>>> d['shares'] = 75
>>> d
{'name': 'AA', 'shares': 75, 'price': 32.2 }
>>>
```
A diferencia de las tuplas, los diccionarios se pueden modificar libremente. Agrega algunos atributos:

```python
>>> d['date'] = (6, 11, 2007)
>>> d['account'] = 12345
>>> d
{'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007), 'account': 12345}
>>>
```

#### Ejercicio 2.3: Otras operaciones adicionales

Si convierte un diccionario en una lista, obtendrá todas sus claves:

```python
>>> list(d)
['name', 'shares', 'price', 'date', 'account']
>>>
```

De manera similar, si usa la fordeclaración para iterar en un diccionario, obtendrá las claves:

```python
>>> for k in d:
        print('k =', k)

k = name
k = shares
k = price
k = date
k = account
>>>
```

Pruebe esta variante que realiza una búsqueda al mismo tiempo:

```python
>>> for k in d:
        print(k, '=', d[k])

name = AA
shares = 75
price = 32.2
date = (6, 11, 2007)
account = 12345
>>>
```

También puede obtener todas las claves utilizando el método `keys()`:

```python
>>> keys = d.keys()
>>> keys
dict_keys(['name', 'shares', 'price', 'date', 'account'])
>>>
```
keys()es un poco inusual porque devuelve un dict_keysobjeto especial .

Se trata de una superposición del diccionario original que siempre le proporciona las claves actuales, incluso si el diccionario cambia. Por ejemplo, intente esto:

```python
>>> del d['account']
>>> keys
dict_keys(['name', 'shares', 'price', 'date'])
>>>
```
Observe cuidadosamente que 'account'desapareció keysaunque no volvió a llamar d.keys().

Una forma más elegante de trabajar con claves y valores juntos es utilizar el items()método. Esto te da (key, value)tuplas:

```python
>>> items = d.items()
>>> items
dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))])
>>> for k, v in d.items():
        print(k, '=', v)

name = AA
shares = 75
price = 32.2
date = (6, 11, 2007)
>>>
```

Si tiene tuplas como items, puede crear un diccionario usando la dict()función. Intentalo:

```python
>>> items
dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))])
>>> d = dict(items)
>>> d
{'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007)}
>>>
```

## 2.2 Contenedores

### 2.2.1: Visión General

Los programas a menudo tienen que trabajar con muchos objetos.

* Una cartera de acciones
* Una tabla de precios de acciones

Hay tres opciones principales para usar.

* Listas. Datos ordenados.
* Diccionarios. Datos desordenados.
* Conjuntos. Colección desordenada de artículos únicos.*

### 2.2.2: Listas como un Contenedor

Utilice una lista cuando sea importante el orden de los datos. Recuerde que las listas pueden contener cualquier tipo de objeto. Por ejemplo, una lista de tuplas.


```python
portfolio = [
    ('GOOG', 100, 490.1),
    ('IBM', 50, 91.3),
    ('CAT', 150, 83.44)
]

portfolio[0]            # ('GOOG', 100, 490.1)
portfolio[2]            # ('CAT', 150, 83.44)
```

### 2.2.3: Construcción de una lista

Construyendo una lista desde cero.

```python
records = []  # Initial empty list

# Use .append() to add more items
records.append(('GOOG', 100, 490.10))
records.append(('IBM', 50, 91.3))
...
```

Un ejemplo al leer registros de un archivo.


```python
records = []  # Lista vacía de inicio

with open('Data/portfolio.csv', 'rt') as f:
    next(f) # Nos saltamos el encabezado
    for line in f:
        row = line.split(',')
        records.append((row[0], int(row[1]), float(row[2])))
```

### 2.2.4: Diccionarios como contenedores

Los diccionarios son útiles si desea búsquedas aleatorias rápidas (por nombre de clave). Por ejemplo, un diccionario de precios de acciones:

```python
prices = {
   'GOOG': 513.25,
   'CAT': 87.22,
   'IBM': 93.37,
   'MSFT': 44.12
}
```

Aquí hay algunas búsquedas simples:

```python
>>> prices['IBM']
93.37
>>> prices['GOOG']
513.25
>>>
```

### 2.2.5: Construcción de un diccionario

Ejemplo de construcción de un dictado desde cero.

```python
prices = {} # Initial empty dict
# Insert new items prices['GOOG'] = 513.25
prices['CAT'] = 87.22
prices['IBM'] = 93.37
```

Un ejemplo que completa el dict a partir del contenido de un archivo.

```python
prices = {} # Initial empty dict
with open('Data/prices.csv', 'rt') as f:
    for line in f:
        row = line.split(',')
        prices[row[0]] = float(row[1])
```

Nota: Si prueba esto en el Data/prices.csvarchivo, encontrará que casi funciona; hay una línea en blanco al final que hace que se bloquee. Necesitará encontrar alguna forma de modificar el código para tener en cuenta eso (vea el ejercicio 2.6).

### 2.2.6: Búsquedas de diccionario

Puede probar la existencia de una clave.

```python
if key in d:
    # YES else:
    # NO
```

Puede buscar un valor que podría no existir y proporcionar un valor predeterminado en caso de que no exista.

name = d.get(key, default)

Un ejemplo:

```python
>>> prices.get('IBM', 0.0)
93.37
>>> prices.get('SCOX', 0.0)
0.0
>>>
```

### 2.2.7: Claves compuestas

Casi cualquier tipo de valor se puede utilizar como clave de diccionario en Python. Una clave de diccionario debe ser de un tipo que sea inmutable. Por ejemplo, tuplas:

```python
holidays = {
  (1, 1) : 'New Years',
  (3, 14) : 'Pi day',
  (9, 13) : "Programmer's day",
}
```

Luego para acceder:

```python
>>> holidays[3, 14]
'Pi day'
>>>
```

Ni una lista, un conjunto ni otro diccionario pueden servir como clave de diccionario, porque las listas y los diccionarios son mutables.

### 2.2.8: Conjuntos (Sets)

Los conjuntos son una colección de elementos únicos desordenados.

```python
tech_stocks = { 'IBM','AAPL','MSFT' }
# alternativamente: tech_stocks = set(['IBM', 'AAPL', 'MSFT'])
```

Los conjuntos son útiles para las pruebas de pertenencia.

```python
>>> tech_stocks
set(['AAPL', 'IBM', 'MSFT'])
>>> 'IBM' in tech_stocks
True
>>> 'FB' in tech_stocks
False
>>>
```

Los conjuntos también son útiles para la eliminación de duplicados.

```python
names = ['IBM', 'AAPL', 'GOOG', 'IBM', 'GOOG', 'YHOO']

unique = set(names)
# unique = set(['IBM', 'AAPL','GOOG','YHOO'])
```

Operaciones de conjuntos adicionales:

```python
names.add('CAT')        # Add an item
names.remove('YHOO')    # Remove an item

s1 | s2                 # Set union
s1 & s2                 # Set intersection
s1 - s2                 # Set difference
```

### 2.2.9: Ejercicios

En estos ejercicios, comenzará a crear uno de los programas principales que se utilizarán durante el resto de este curso. Haga su trabajo en el archivo `Work/report.py`.

#### Ejercicio 2.4: Una lista de tuplas

El archivo Data/portfolio.csvcontiene una lista de acciones en una cartera. En el ejercicio 1.30 , escribió una función portfolio_cost(filename)que leyó este archivo y realizó un cálculo simple.

Tu código debería haberse visto así:

```python
# pcost.py
import csv

def portfolio_cost(filename):
    '''Computes the total cost (shares*price) of a portfolio file'''
    total_cost = 0.0

    with open(filename, 'rt') as f:
        rows = csv.reader(f)
        headers = next(rows)
        for row in rows:
            nshares = int(row[1])
            price = float(row[2])
            total_cost += nshares * price
    return total_cost
```

Usando este código como una guía aproximada, cree un nuevo archivo report.py. En ese archivo, defina una función read_portfolio(filename)que abra un archivo de cartera determinado y lo lea en una lista de tuplas. Para hacer esto, va a realizar algunas modificaciones menores al código anterior.

Primero, en lugar de definir total_cost = 0, creará una variable que inicialmente se establece en una lista vacía. Por ejemplo:

```python
portfolio = []
```

A continuación, en lugar de sumar el costo total, convertirá cada fila en una tupla exactamente como lo hizo en el último ejercicio y la agregará a esta lista. Por ejemplo:

```python
for row in rows:
    holding = (row[0], int(row[1]), float(row[2]))
    portfolio.append(holding)
```
Finalmente, devolverá la portfoliolista resultante .

Experimente con su función de forma interactiva (solo un recordatorio de que para hacer esto, primero debe ejecutar el report.pyprograma en el intérprete):

Sugerencia: Haga uso de `-i` al ejecutar el archivo en la terminal, e.g. `$ python -i archivo.py`

```python
>>> portfolio = read_portfolio('Data/portfolio.csv')
>>> portfolio
[('AA', 100, 32.2), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('MSFT', 200, 51.23),
    ('GE', 95, 40.37), ('MSFT', 50, 65.1), ('IBM', 100, 70.44)]
>>>
>>> portfolio[0]
('AA', 100, 32.2)
>>> portfolio[1]
('IBM', 50, 91.1)
>>> portfolio[1][1]
50
>>> total = 0.0
>>> for s in portfolio:
        total += s[1] * s[2]

>>> print(total)
44671.15
>>>
```

Esta lista de tuplas que ha creado es muy similar a una matriz 2-D. Por ejemplo, puede acceder a una columna y una fila específicas mediante una búsqueda como portfolio[row][column]dónde rowy columnson números enteros.

Dicho esto, también puede reescribir el último ciclo for usando una declaración como esta:

```python
>>> total = 0.0
>>> for name, shares, price in portfolio:
            total += shares*price

>>> print(total)
44671.15
>>>
```

#### Ejercicio 2.5: Lista de diccionarios

Tome la función que escribió en el ejercicio 2.4 y modifíquela para representar cada acción de la cartera con un diccionario en lugar de una tupla. En este diccionario, use los nombres de campo de "nombre", "acciones" y "precio" para representar las diferentes columnas en el archivo de entrada.

Experimente con esta nueva función de la misma manera que lo hizo en el ejercicio 2.4.

```python
>>> portfolio = read_portfolio('Data/portfolio.csv')
>>> portfolio
[{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1},
    {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23},
    {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1},
    {'name': 'IBM', 'shares': 100, 'price': 70.44}]
>>> portfolio[0]
{'name': 'AA', 'shares': 100, 'price': 32.2}
>>> portfolio[1]
{'name': 'IBM', 'shares': 50, 'price': 91.1}
>>> portfolio[1]['shares']
50
>>> total = 0.0
>>> for s in portfolio:
        total += s['shares']*s['price']

>>> print(total)
44671.15
>>>
```

Aquí, notará que se accede a los diferentes campos para cada entrada mediante nombres de clave en lugar de números de columna numéricos. Esto se prefiere a menudo porque el código resultante es más fácil de leer más tarde.

Ver diccionarios y listas de gran tamaño puede resultar complicado. Para limpiar la salida para la depuración, considere usar la función `pprint`.

```python
>>> from pprint import pprint
>>> pprint(portfolio)
[{'name': 'AA', 'price': 32.2, 'shares': 100},
    {'name': 'IBM', 'price': 91.1, 'shares': 50},
    {'name': 'CAT', 'price': 83.44, 'shares': 150},
    {'name': 'MSFT', 'price': 51.23, 'shares': 200},
    {'name': 'GE', 'price': 40.37, 'shares': 95},
    {'name': 'MSFT', 'price': 65.1, 'shares': 50},
    {'name': 'IBM', 'price': 70.44, 'shares': 100}]
>>>
```

#### Ejercicio 2.6: Diccionarios como contenedor

Un diccionario es una forma útil de realizar un seguimiento de los elementos en los que desea buscar elementos utilizando un índice que no sea un número entero. En el shell de Python, intente jugar con un diccionario:

```python
>>> prices = { }
>>> prices['IBM'] = 92.45
>>> prices['MSFT'] = 45.12
>>> prices
... look at the result ...
>>> prices['IBM']
92.45
>>> prices['AAPL']
... look at the result ...
>>> 'AAPL' in prices
False
>>>
```
El archivo Data/prices.csvcontiene una serie de líneas con precios de acciones. El archivo se parece a esto:

```python
"AA",9.22
"AXP",24.85
"BA",44.85
"BAC",11.27
"C",3.72
...
```
Escriba una función read_prices(filename)que lea un conjunto de precios como este en un diccionario donde las claves del diccionario son los nombres de las acciones y los valores en el diccionario son los precios de las acciones.

Para hacer esto, comience con un diccionario vacío y comience a insertar valores en él tal como lo hizo anteriormente. Sin embargo, ahora está leyendo los valores de un archivo.

Usaremos esta estructura de datos para buscar rápidamente el precio de un nombre de acción determinado.

Algunos pequeños consejos que necesitará para esta parte. Primero, asegúrese de usar el csvmódulo tal como lo hizo antes, no es necesario reinventar la rueda aquí.

```python
>>> import csv
>>> f = open('Data/prices.csv', 'r')
>>> rows = csv.reader(f)
>>> for row in rows:
        print(row)

['AA', '9.22']
['AXP', '24.85']
...
[]
>>>
```
La otra pequeña complicación es que el Data/prices.csvarchivo puede tener algunas líneas en blanco. Observe cómo la última fila de datos de arriba es una lista vacía, lo que significa que no había datos presentes en esa línea.

Existe la posibilidad de que esto provoque la muerte de su programa con una excepción. Utilice las declaraciones tryy exceptpara detectar esto según corresponda. Pensamiento: ¿sería mejor protegerse contra datos incorrectos con una ifdeclaración -en su lugar?

Una vez que haya escrito su función read_prices(), pruébela de forma interactiva para asegurarse de que funcione:

```python
>>> prices = read_prices('Data/prices.csv')
>>> prices['IBM']
106.28
>>> prices['MSFT']
20.89
>>>
```

La otra pequeña complicación es que el archivo `Data/prices.csv` puede tener algunas líneas en blanco. Observe cómo la última fila de datos de arriba es una lista vacía, lo que significa que no había datos presentes en esa línea.

Existe la posibilidad de que esto provoque la muerte de su programa con una excepción. Utilice las declaraciones tryy exceptpara detectar esto según corresponda. Pensamiento: ¿sería mejor protegerse contra datos incorrectos con una ifdeclaración -en su lugar?

Una vez que haya escrito su función `read_prices()`, pruébela de forma interactiva para asegurarse de que funcione:

```python
>>> prices = read_prices('Data/prices.csv')
>>> prices['IBM']
106.28
>>> prices['MSFT']
20.89
>>>
```

#### Ejercicio 2.7: Descubra se puede jubilar

Complete este trabajo agregando algunas declaraciones adicionales a su programa `report.py` que calculen ganancias / pérdidas. Estas declaraciones deben tomar la lista de acciones del ejercicio 2.5 y el diccionario de precios del ejercicio 2.6 y calcular el valor actual de la cartera junto con la ganancia / pérdida.

## 2.3 Salida formateada

Esta sección es una pequeña digresión, pero cuando trabaja con datos, a menudo desea producir resultados estructurados (tablas, etc.). Por ejemplo:

```
      Name      Shares        Price
----------  ----------  -----------
        AA         100        32.20
       IBM          50        91.10
       CAT         150        83.44
      MSFT         200        51.23
        GE          95        40.37
      MSFT          50        65.10
       IBM         100        70.44
```
### 2.3.1: Formateo de cadena

Una forma de formatear cadenas en Python 3.6+ es con f-strings.

```python
>>> name = 'IBM'
>>> shares = 100
>>> price = 91.1
>>> f'{name:>10s} {shares:>10d} {price:>10.2f}'
' IBM 100 91.10'
>>>
```

La pieza `{expression:format}` se reemplaza.

Se usa comúnmente con print.

```python
print(f'{name:>10s} {shares:>10d} {price:>10.2f}')
```
### 2.3.2: Códigos de formato

Códigos de formato (después de que el :interior de la {}) son similares a C printf(). Los códigos comunes incluyen:

```
d       Decimal integer
b       Binary integer
x       Hexadecimal integer
f       Float as [-]m.dddddd
e       Float as [-]m.dddddde+-xx
g       Float, but selective use of E notation
s       String
c       Character (from integer)
```

Los modificadores comunes ajustan el ancho del campo y la precisión decimal. Esta es una lista parcial:

```
:>10d   Integer right aligned in 10-character field
:<10d   Integer left aligned in 10-character field
:^10d   Integer centered in 10-character field
:0.2f   Float with 2 digit precision
```

### 2.3.3: Formateo de diccionarios

Puede utilizar el format_map()método para aplicar formato de cadena a un diccionario de valores:

```
>>> s = {
    'name': 'IBM',
    'shares': 100,
    'price': 91.1
}
>>> '{name:>10s} {shares:10d} {price:10.2f}'.format_map(s)
' IBM 100 91.10'
>>>
```

Utiliza los mismos códigos que f-stringspero toma los valores del diccionario suministrado.

### 2.3.4: El método format()

Existe un método format()que puede aplicar formato a argumentos o argumentos de palabras clave.

```python
>>> '{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1)
' IBM 100 91.10'
>>> '{:10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1)
' IBM 100 91.10'
>>>
```

Francamente, format()es un poco prolijo. Prefiero las cuerdas f.

### 2.3.5: Formateo al estilo C

También puede utilizar el operador de formato `%`.

```python
>>> 'The value is %d' % 3
'The value is 3'
>>> '%5d %-5d %10d' % (3,4,5)
' 3 4 5'
>>> '%0.2f' % (3.1415926,)
'3.14'
```

Esto requiere un solo elemento o una tupla a la derecha. Códigos de formato son el modelo de la C `printf()` también.

Nota: Este es el único formato disponible en cadenas de bytes.

```python
>>> b'%s has %n messages' % (b'Dave', 37)
b'Dave has 37 messages'
>>>
```

### 2.3.6: Ejercicios

#### Ejercicio 2.8: Como formatear numeros

Un problema común al imprimir números es especificar el número de decimales. Una forma de solucionar este problema es usar f-strings. Prueba estos ejemplos:

```python
>>> value = 42863.1
>>> print(value)
42863.1
>>> print(f'{value:0.4f}')
42863.1000
>>> print(f'{value:>16.2f}')
        42863.10
>>> print(f'{value:<16.2f}')
42863.10
>>> print(f'{value:*>16,.2f}')
*******42,863.10
>>>
```

La documentación completa sobre los códigos de formato utilizados para las cadenas f se puede encontrar aquí . El formateo también se realiza a veces utilizando el operador `%` de cadenas.

```python
>>> print('%0.4f' % value)
42863.1000
>>> print('%16.2f' % value)
        42863.10
>>>
```

La documentación sobre varios códigos utilizados con %se puede encontrar aquí.

Aunque se usa comúnmente con print, el formato de cadena no está ligado a la impresión. Si desea guardar una cadena formateada. Simplemente asígnelo a una variable.

```python
>>> f = '%0.4f' % value
>>> f
'42863.1000'
>>>
```

#### Ejercicio 2.9: Coleccionando data

En el ejercicio 2.7, escribió un programa llamado report.pyque calculó la ganancia / pérdida de una cartera de acciones. En este ejercicio, comenzará a modificarlo para producir una tabla como esta:

```python
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
```

En este informe, "Precio" es el precio actual de la acción de la acción y "Cambio" es el cambio en el precio de la acción desde el precio de compra inicial.

Para generar el informe anterior, primero querrá recopilar todos los datos que se muestran en la tabla. Escriba una función `make_report()` que tome una lista de existencias y un diccionario de precios como entrada y devuelva una lista de tuplas que contenga las filas de la tabla anterior.

Agregue esta función a su report.pyarchivo. Así es como debería funcionar si lo prueba de forma interactiva:

```python
>>> portfolio = read_portfolio('Data/portfolio.csv')
>>> prices = read_prices('Data/prices.csv')
>>> report = make_report(portfolio, prices)
>>> for r in report:
        print(r)

('AA', 100, 9.22, -22.980000000000004)
('IBM', 50, 106.28, 15.180000000000007)
('CAT', 150, 35.46, -47.98)
('MSFT', 200, 20.89, -30.339999999999996)
('GE', 95, 13.48, -26.889999999999997)
...
>>>
```

#### Ejercicio 2.10: Imprimiendo una tabla formateada

Rehaga el bucle for del ejercicio 2.9, pero cambie la instrucción print para formatear las tuplas.

```python
>>> for r in report:
        print('%10s %10d %10.2f %10.2f' % r)

          AA        100       9.22     -22.98
         IBM         50     106.28      15.18
         CAT        150      35.46     -47.98
        MSFT        200      20.89     -30.34
...
>>>
```

También puede expandir los valores y usar f-strings. Por ejemplo:

```python
>>> for name, shares, price, change in report:
        print(f'{name:>10s} {shares:>10d} {price:>10.2f} {change:>10.2f}')

          AA        100       9.22     -22.98
         IBM         50     106.28      15.18
         CAT        150      35.46     -47.98
        MSFT        200      20.89     -30.34
...
>>>
```

Tome las declaraciones anteriores y agréguelas a su report.pyprograma. Haga que su programa tome la salida de la función `make_report()` e imprima una tabla bien formateada como se muestra.

#### Ejercicio 2.11: Agregando algunos encabezados

Suponga que tiene una tupla de nombres de encabezado como este:

```python
headers = ('Name', 'Shares', 'Price', 'Change')
```

Agregue código a su programa que toma la tupla de encabezados anterior y crea una cadena donde cada nombre de encabezado está alineado a la derecha en un campo de 10 caracteres de ancho y cada campo está separado por un solo espacio.

```python
' Name Shares Price Change'
```

Escriba código que tome los encabezados y cree la cadena de separación entre los encabezados y los datos que siguen. Esta cadena es solo un grupo de caracteres "-" debajo de cada nombre de campo. Por ejemplo:

```python
'---------- ---------- ---------- -----------'
```

Cuando haya terminado, su programa debería producir la tabla que se muestra en la parte superior de este ejercicio.

```
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
```

#### Ejercicio 2.12: Un reto

¿Cómo modificaría su código para que el precio incluya el símbolo de moneda ($) y la salida se vea así:

```
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100      $9.22     -22.98
       IBM         50    $106.28      15.18
       CAT        150     $35.46     -47.98
      MSFT        200     $20.89     -30.34
        GE         95     $13.48     -26.89
      MSFT         50     $20.89     -44.21
       IBM        100    $106.28      35.84
```

***

## 2.4 Secuencias

### 2.4.1: Tipos de secuencias

### 2.4.2: Rebanar

### 2.4.3: Rebanar y reasignar

### 2.4.4: Secuencia de reducciones

### 2.4.5: Iteracion sobre una secuencia

### 2.4.6: La declaración break

### 2.4.7: La declaración continue

### 2.4.8: Ciclando sobre enteros

### 2.4.9: La función enumerate()

### 2.4.10: For y tuplas

### 2.4.11: La función zip()

### 2.4.12: Ejercicios

#### Ejercicio 2.13: Contar

#### Ejercicio 2.14: Mas operaciones sobre secuencias

#### Ejercicio 2.15: Un ejemplo práctico de enumerate()

#### Ejercicio 2.16: Usando la función zip()

#### Ejercicio 2.17: Invirtiendo un diccionario

## 2.5 El modulo collections

### 2.5.1: Ejemplo: contando cosas

### 2.5.2: Contadores

### 2.5.3: Ejemplo: asignaciones uno-muchos

### 2.5.4: Ejemplo: guardando un historial

### 2.5.5: Ejercicios

#### 2.19: Tabulación con contadores

#### Comentario: el modulo collections

## 2.6 List comprehensions

### 2.6.1: Creando nuevas listas

### 2.6.2: Filtrar

### 2.6.3: Casos de uso

### 2.6.4: Sintaxis general

#### 2.6.5: Digresión histórica

#### 2.6.6: Ejercicios

#### 2.19: List comprehensions
#### 2.20: Reducciones de secuencia
#### 2.21: Consulta de datos
#### 2.22: Extracción de datos
#### 2.23: Extracción de datos desde archivos CSV
#### Comentario

## 2.7 El modelo Objeto

### 2.7.1: Asignacion

### 2.7.2: Ejemplo de asignacion

### 2.7.3: Reasignacion de valores

### 2.7.4: Algunos peligros

### 2.7.5: Identidad y referencias

### 2.7.6: Copias superficiales

#### 2.29: Copias profundas

#### 2.30: Nombres, valores, tipos

#### 2.31: Verificación de tipo

#### 2.32: Todo es un objeto

#### 2.33: Ejercicios

#### Ejercicio 2.24: Data de primera-clase

#### Ejercicio 2.25: Creando diccionarios
#### Ejercicio 2.26: El horizonte
