# 2. Trabajando con data

Conoceremos las estructuras de datos de fundamental importancia en Python: tuples, lists, sets y dictionaries. Presentaremos algunos patrones comunes para el manejo de datos y discutiremos el modelo de objetos en Python.

## 2.1 Tipos y estructuras de data

Esta sección presenta estructuras de datos en forma de tuplas y diccionarios.

### 2.1.1 Tipos primitivos

Python tiene algunos tipos primitivos de datos:

* Enteros
* Números de punto flotante
* Cadenas (texto)

Aprendimos sobre esto en la introducción.

### 2.1.2 Tipo `None`

```python
email_address = None
```

`None` se utiliza a menudo como marcador de posición para un valor opcional o faltante. Eso se evalúa como "Falso" en condicionales.


```python
if email_address:
    send_email(email_address, msg)
```

### 2.1.3: Estructuras de data

Los programas reales tienen datos más complejos. Por ejemplo, información sobre una participación en acciones:

```code
100 acciones de GOOG a $490.10
```

Este es un "objeto" con tres partes:

* Nombre o símbolo de la acción ("GOOG", una cadena)
* Número de acciones (100, un número entero)
* Precio (490,10 un punto flotante)

### 2.1.4: Tuplas

Una tupla es una colección de valores agrupados.

Ejemplo:
```python
s = ('GOOG', 100, 490.1)
```

A veces el `()` es omitido.

```python
s = 'GOOG', 100, 490.1'
```

Casos especiales (0-tupla, 1-tupla).

```python
t = ()            # Una tupla vacía
w = ('GOOG', )    # Una tupla de 1-item
```

Las tuplas se utilizan a menudo para representar registros o estructuras *simples*. Normalmente, es un único *objeto* de varias partes.

Una buena analogía: *Una tupla es como una sola fila en una tabla de base de datos.*

El contenido de la tupla está ordenado (como una matriz).

```python
s = ('GOOG', 100, 490.1)
name = s[0]                 # 'GOOG'
shares = s[1]               # 100
price = s[2]                # 490.1
```

Sin embargo, el contenido no se puede modificar.

```python
>>> s[1] = 75
TypeError: object does not support item assignment
```

Sin embargo, puede crear una nueva tupla basada en una tupla actual.

```python
s = (s[0], 75, s[2])
```

Las tuplas tienen más que ver con empaquetar elementos relacionados en una sola *entidad*,
que con cualquier otra cosa.

```python
s = ('GOOG', 100, 490.1)
```

Por tanto, la tupla es fácil de pasar a otras partes de un programa como un solo objeto.

### 2.1.5: Desempaque de Tuplas

Para usar la tupla en otro lugar, puede desempaquetar sus partes en variables.

```python
name, shares, price = s
print('Cost', shares * price)
```

The number of variables on the left must match the tuple structure.

```python
name, shares = s     # ERROR
Traceback (most recent call last):
...
ValueError: too many values to unpack
```

### 2.1.6 Tuplas vs Listas

Tuples look like read-only lists. However, tuples are most often used
for a *single item* consisting of multiple parts.  Lists are usually a
collection of distinct items, usually all of the same type.

```python
record = ('GOOG', 100, 490.1)       # Una tupla que representa un registro en una cartera

symbols = [ 'GOOG', 'AAPL', 'IBM' ]  # Una lista que representa tres símbolos de acciones
```

### 2.1.7 Diccionarios

Un diccionario es la asignación de claves a valores. A veces también se le llama una tabla hash o matriz asociativa. Las claves sirven como índices para acceder a los valores.

```python
s = {
    'name': 'GOOG',
    'shares': 100,
    'price': 490.1
}
```

### 2.1.8 Operaciones comunes

To get values from a dictionary use the key names.

```python
>>> print(s['name'], s['shares'])
GOOG 100
>>> s['price']
490.10
>>>
```

Para agregar o modificar valores, asigne usando los nombres de las claves.

```python
>>> s['shares'] = 75
>>> s['date'] = '6/6/2007'
>>>
```

Para eliminar un valor, use la instrucción `del`.

```python
>>> del s['date']
>>>
```

### 2.1.9 ¿Porqué diccionarios?

Los diccionarios son útiles cuando hay * muchos * valores diferentes y esos valores
puede ser modificado o manipulado. Los diccionarios hacen que su código sea más legible.

```python
s['price']
# vs
s[2]
```

### 2.1.10 Ejercicios

En los últimos ejercicios, escribió un programa que lee un archivo de datos `Data/portfolio.csv`.
Usando el módulo `csv`, es fácil leer el archivo fila por fila.

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> next(rows)
['name', 'shares', 'price']
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>>
```

Aunque leer el archivo es fácil, a menudo querrá hacer más con el datos que leerlos.
Por ejemplo, tal vez desee almacenarlo y comience a realizar algunos cálculos sobre él. Desafortunadamente, una "fila" sin procesar de datos no le da suficiente para trabajar.
Por ejemplo, incluso un el cálculo matemático simple no funciona:

```python
>>> row = ['AA', '100', '32.20']
>>> cost = row[1] * row[2]
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: can't multiply sequence by non-int of type 'str'
>>>
```

Para hacer más, normalmente desea interpretar los datos sin procesar de alguna manera
y convertirlo en un tipo de objeto más útil para que pueda trabajar
con él más tarde. Dos opciones simples son tuplas o diccionarios.

### Ejercicio 2.1: Tuplas

En el indicador interactivo, cree la siguiente tupla que represente la fila anterior, pero con las columnas numéricas convertidas a los números adecuados:

```python
>>> t = (row[0], int(row[1]), float(row[2]))
>>> t
('AA', 100, 32.2)
>>>
```

Con esto, ahora puede calcular el costo total multiplicando las acciones y el precio:

```python
>>> cost = t[1] * t[2]
>>> cost
3220.0000000000005
>>>
```

¿Las matemáticas están rotas en Python? ¿Cuál es el problema con la respuesta de
3220.0000000000005?

Este es un artefacto del hardware de punto flotante en su computadora que solo puede representar decimales con precisión en Base-2, no en Base-10. Incluso para cálculos simples que involucran decimales en base 10, se introducen pequeños errores. Esto es normal, aunque quizás un poco sorprendente si no lo ha visto antes.

Esto sucede en todos los lenguajes de programación que utilizan decimales de punto flotante, pero a menudo se oculta al imprimir. Por ejemplo:

```python
>>> print(f'{cost:0.2f}')
3220.00
>>>
```
Las tuplas son de solo lectura. Verifique esto intentando cambiar el número de acciones a 75.

```python
>>> t[1] = 75
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>>
```

Aunque no puede cambiar el contenido de la tupla, siempre puede crear una tupla completamente nueva que reemplace a la anterior.

```python
>>> t = (t[0], 75, t[2])
>>> t
('AA', 75, 32.2)
>>>
```

Siempre que reasigne un nombre de variable existente como este, el valor anterior se descarta. Aunque la asignación anterior puede parecer que está modificando la tupla, en realidad está creando una nueva tupla y desechando la anterior.

Las tuplas se utilizan a menudo para empaquetar y descomprimir valores en variables. Intente lo siguiente:

```python
>>> name, shares, price = t
>>> name
'AA'
>>> shares
75
>>> price
32.2
>>>
```
Tome las variables anteriores y vuelva a empaquetarlas en una tupla

```python
>>> t = (name, 2*shares, price)
>>> t
('AA', 150, 32.2)
>>>
```

### Ejercicio 2.2: Diccionarios como estructura de datos

Una alternativa a una tupla es crear un diccionario.

```python
>>> d = {
        'name' : row[0],
        'shares' : int(row[1]),
        'price'  : float(row[2])
    }
>>> d
{'name': 'AA', 'shares': 100, 'price': 32.2 }
>>>
```

Calcule el costo total de esta participación:

```python
>>> cost = d['shares'] * d['price']
>>> cost
3220.0000000000005
>>>
```

Compare este ejemplo con el mismo cálculo que involucra tuplas anterior. Cambie el número de acciones a 75.

```python
>>> d['shares'] = 75
>>> d
{'name': 'AA', 'shares': 75, 'price': 32.2 }
>>>
```
A diferencia de las tuplas, los diccionarios se pueden modificar libremente. Agrega algunos atributos:

```python
>>> d['date'] = (6, 11, 2007)
>>> d['account'] = 12345
>>> d
{'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007), 'account': 12345}
>>>
```

### Ejercicio 2.3: Otras operaciones adicionales

Si convierte un diccionario en una lista, obtendrá todas sus claves:

```python
>>> list(d)
['name', 'shares', 'price', 'date', 'account']
>>>
```

De manera similar, si usa la fordeclaración para iterar en un diccionario, obtendrá las claves:

```python
>>> for k in d:
        print('k =', k)

k = name
k = shares
k = price
k = date
k = account
>>>
```

Pruebe esta variante que realiza una búsqueda al mismo tiempo:

```python
>>> for k in d:
        print(k, '=', d[k])

name = AA
shares = 75
price = 32.2
date = (6, 11, 2007)
account = 12345
>>>
```

También puede obtener todas las claves utilizando el método `keys()`:

```python
>>> keys = d.keys()
>>> keys
dict_keys(['name', 'shares', 'price', 'date', 'account'])
>>>
```
keys()es un poco inusual porque devuelve un dict_keysobjeto especial .

Se trata de una superposición del diccionario original que siempre le proporciona las claves actuales, incluso si el diccionario cambia. Por ejemplo, intente esto:

```python
>>> del d['account']
>>> keys
dict_keys(['name', 'shares', 'price', 'date'])
>>>
```
Observe cuidadosamente que 'account'desapareció keysaunque no volvió a llamar d.keys().

Una forma más elegante de trabajar con claves y valores juntos es utilizar el items()método. Esto te da (key, value)tuplas:

```python
>>> items = d.items()
>>> items
dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))])
>>> for k, v in d.items():
        print(k, '=', v)

name = AA
shares = 75
price = 32.2
date = (6, 11, 2007)
>>>
```

Si tiene tuplas como items, puede crear un diccionario usando la dict()función. Intentalo:

```python
>>> items
dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))])
>>> d = dict(items)
>>> d
{'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007)}
>>>
```

## 2.2 Contenedores

### 2.2.1: Panorama

### 1.2.2: Listas como un Contenedor

### 1.2.3: Construcción de una lista

### 1.2.4: Diccionarios como contenedores

### 1.2.5: Construcción de un diccionario

### 1.2.6: Búsquedas de diccionario

### 1.2.7: Claves compuestas

### 1.2.8: Variables

### 1.2.9: Conjuntos (Sets)

### 1.2.10: Ejercicios

#### Ejercicio 2.4: Una lista de tuplas

#### Ejercicio 2.5: Lista de diccionarios

#### Ejercicio 2.6: Diccionarios como contenedor

#### Ejercicio 2.8: Descubre si te puedes jubilar

## 2.3 Salida formateada

### 2.3.1: Formateo de cadena

### 2.3.2: Códigos de formato

### 2.3.3: Formateo de diccionarios

### 2.3.4: El método format()

### 2.3.5: Formateo al estilo C

### 2.3.6: Ejercicios

#### Ejercicio 2.8: Como formatear numeros

#### Ejercicio 2.9: Coleccionando data

#### Ejercicio 2.10: Imprimiendo una tabla formateada

#### Ejercicio 2.11: Agregando algunos encabezados

#### Ejercicio 2.12: Un reto

***

## 2.4 Secuencias

### 2.4.1: Tipos de secuencias

### 2.4.2: Rebanar

### 2.4.3: Rebanar y reasignar

### 2.4.4: Secuencia de reducciones

### 2.4.5: Iteracion sobre una secuencia

### 2.4.6: La declaración break

### 2.4.7: La declaración continue

### 2.4.8: Ciclando sobre enteros

### 2.4.9: La función enumerate()

### 2.4.10: For y tuplas

### 2.4.11: La función zip()

### 2.4.12: Ejercicios

#### Ejercicio 2.13: Contar

#### Ejercicio 2.14: Mas operaciones sobre secuencias

#### Ejercicio 2.15: Un ejemplo práctico de enumerate()

#### Ejercicio 2.16: Usando la función zip()

#### Ejercicio 2.17: Invirtiendo un diccionario

## 2.5 El modulo collections

### 2.5.1: Ejemplo: contando cosas

### 2.5.2: Contadores

### 2.5.3: Ejemplo: asignaciones uno-muchos

### 2.5.4: Ejemplo: guardando un historial

### 2.5.5: Ejercicios

#### 2.19: Tabulación con contadores

#### Comentario: el modulo collections

## 2.6 List comprehensions

### 2.6.1: Creando nuevas listas

### 2.6.2: Filtrar

### 2.6.3: Casos de uso

### 2.6.4: Sintaxis general

#### 2.6.5: Digresión histórica

#### 2.6.6: Ejercicios

#### 2.19: List comprehensions
#### 2.20: Reducciones de secuencia
#### 2.21: Consulta de datos
#### 2.22: Extracción de datos
#### 2.23: Extracción de datos desde archivos CSV
#### Comentario

## 2.7 El modelo Objeto

### 2.7.1: Asignacion

### 2.7.2: Ejemplo de asignacion

### 2.7.3: Reasignacion de valores

### 2.7.4: Algunos peligros

### 2.7.5: Identidad y referencias

### 2.7.6: Copias superficiales

#### 2.29: Copias profundas

#### 2.30: Nombres, valores, tipos

#### 2.31: Verificación de tipo

#### 2.32: Todo es un objeto

#### 2.33: Ejercicios

#### Ejercicio 2.24: Data de primera-clase

#### Ejercicio 2.25: Creando diccionarios
#### Ejercicio 2.26: El horizonte
